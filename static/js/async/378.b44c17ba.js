"use strict";
(self.webpackChunkbot = self.webpackChunkbot || []).push([
  ["378"],
  {
    86229: function (e, t, o) {
      o.d(t, {
        DV: () => r,
        M8: () => s,
        N$: () => i,
        dK: () => c,
        dp: () => n,
        e_: () => l,
        fK: () => u,
        xY: () => a,
      });
      let i =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAAGXcA1uAAAAAXNSR0IArs4c6QAAAK9JREFUSA3tVUkOgCAMROP/f4PfU4iOaWQKLYmBg71AOksXTAyhGkeKKuECjTSDUwcFxVdNawNgQ10omJNKROqiJbMJsKJZgKgEouuESRYVFVxO35JTnxGDvk9aWQ5GCXfSPbRbsLHysr0lBeMESaKE3hkmbKk230SY9Ulky5rG/SVJU8udPrMU5s7w9bEugUlN886MWiJN86/o2dywFQ17g10b+dlJefH9X0t9X+YETM6gfmoeI+MAAAAASUVORK5CYII=",
        a =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAWBJREFUOI2dk81KQmEQhp/5zgHRjhtz0apMXBUSdAcVLWrnxhswsHARSLcRhYm00CvIRbugrCtIaJHtIqlFQUsPBeY50yINM7WfZzV8M+/MOzCfMED8wE2q0Q0VVgSJASjaNEJNoHy7Fb7ur5dekChooGO7ewJZwAw27uIBh6Gok2+kpf3ZIFHQgG+7JwpLI4RfULiYiDprjbS0DYBvu/u/FXenLr88u7sAEj9wk2rp1TDb1VQQXyF9/Dp0HctnwajRjWFiAF9BRxuxOpZmJF5qNRTmfmt/gGujMD0qW00FOUoFxzWYsRnjcnHK+smBGoGHn6rGcG8Qzv6v11MjUObjwr5Rf/K4fByaAvA8IxUBmC21ikDub8Mp3OXC2wYgFHXyCOd/kNcitrMD3QNqpKUdmnTWUYqMWKdnG6UQsZz1elbeoO839kgUW/MdSzOisgrEus9N0FPPSOV+M3zTX/8O8E9xAaZDaSsAAAAASUVORK5CYII=",
        l =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAAXNSR0IArs4c6QAAAvlJREFUaAXtmU1u00AUxxPEGoluKMcgJ8gCARsW9CZ0ReEU5BwFiYpWqtgYiQuQFSygJ2CRLV2E39+ZZ42dGc84XxIwT3p9X//34VfbsZPRaGNaQkpGPNu4yGESGfHUOtnYte0b6G8NdABJu7NoG4KXmi1GwUTACwtYomzp5r9ripP3/KB8zj7q4P4t0z9o9PfJowM0NhD6D9NN+sFm1xb05Rjybe171nKkDBLqfw6yt1Oqjjo3F4XArbli1dfmT7YpgOQGWPanLgjfFXyn6x9sU+QMfhdKxL/1OfSAGreh4vIR643H8pQ4hydRQCAAPv9owJ7AF1YH/bKr+z7FsPMbdBP8ZNNNOuwE+6v0bPILpJLAXsAvUrgSLxsoG4hsgAtoDDe3CoPhW7uFW8yXOffzcxK++ElOfxzwDXcxafAmhvscfjO8opdBgSfwjedqVPxaXbB5A0op5P+GH8ZwqXgwj6RtaO1kiDYJBiJOJop+HuScRZGyLfcUq2p5nJHVgAnrQzepXF/HnMIVnEckt84Os02qSkdfYN/Pq75KnpPQPFVYMZOBBq2B/EaxFVWApga0x2WT8vu64UIyq0EoMdfXeuC3JFZxhP7L7ByZe0Q5tQqmbKBsoGygbOCv2wAfHU/1SQp9Sw0P5nuNJCeFPUicYY7hW8fHqaYOr4dR5UQfSFN1dhJnAD1a/4RF2RsFq8d10Q0ce+LYyYy9RWiulw/R615gIEiOvuASpb/IDeRv7aLxq7r9FgOQbwvY7g2s72ho0vurgjuIfYmPfbMNijGhvsoSnQxKHABW7brDcvkhN23IBVS5otPc4hvgrHa1QW5/CpvR26loHkKuQuuvc/L7+BDO4sT0tiZ6ZL6dSgrr/VGkd54WrdzpYUM4FVJNF1u0CieM7g90CfjoM4Dn8BTu3v6u8LW2jZ3rA1rXlKz0Zy/Ehk7dlma7bkDdmav9cte1m3o0mLgmweugAW6gUHfuau/n/LeZaHLtGu1DXFufIssGygb+kw38ARimnBqQbBHiAAAAAElFTkSuQmCC",
        n =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAAXNSR0IArs4c6QAAA45JREFUaAXtWDFrFUEQzoU0QhpjFVRs/Cc2Sf6AxD4BQSF/QBFtbPwDYici2ImFIqaVlBEEK7FICBaxCFEQRM/v29vZzO7O3dv3uGCEXdg3M998M7O7d7e37+bmZmpt2y4xEPLITABHazpOC0wLwt5wtVKHDGBeFJEg7og+okTaVY5hUgslSQwGFJhb2tZ6mARI3XQ77x/YbzQR9mlMTpc4u3rDoWEFomXtGe5+0zSXg28oCL69IT8r/kwJYocLF0p1yi2ITwl2YiL6+MTq5iQZiUNvtO24GaAywLc+5FfUqp7tFdCXUeulo0bMMfoy+WY8QdUcMU0O/xfPuZ/6fOJtyZH56chABcC94oMXFWyqOlffs2YFXge4hi3gu05gEU3Mj24ZklvDtkUCfgHdfMiBu+cXMnos3QbGZHDsQVyyEs+CYaYh9yzxNaauQF2BWVaATzL6WG01GwMzE4TgfhSdGzKyAUi8z5HvzEKA5Ez08TOkA34jGInCeDT5H2EX6Di9O+k17+d2nW1kwDjz0JL6Pa85xfKRS5BP0T8oV6aSWwYqFoPQHiqoVyUxc5pgwgLnM3loFxNXZJIQATRMULHgf+5596AfKlemmrkIou2gZxfQJ6b/Lfov9CdZVgDAN9B5fLFnANy9TyH7ijyD72pPch5ZeIu7uynjwOGqQrDI1H+zJJ6Jtb6gK2mH1jVnSFcx+0O86qsrUFegrkBdgboC/9MKZK91vPBG/ac88mLEnxmt5Hxjs2kfTDnHTH3M0HlKdNTioYxtXfM7KB6X9gddiJA8OHHgPESx8UCVXbEQaCjg30bnMf+c4TYh1kCX702szTFwLK6ZQRoUIiSPllwNHjOLBw7uFfQf6GxH6LtO635u6lpDOuicCGtzDO6YCxndGWY8SWymswBE6F2XoG0PIN3EIVfQ36G/KkhhUhDrmunUYDFRByU6cvBsL+0Qyh30iV8QkzSRKcki0DKKiVZwgiHXPDrv4W8+74uEUmz6+Ml3RjGxpzTiP/ocL4UC+5HHvgo2rfTx5ROQAC+5K5hfsNOBgLeAzgH/RtftNYzzKd+yweOuIzuRzlE+AUmMaH6QkK3U/Owi3FQi7gH6+xQfssHnzsPGmu5zDfkOwc9QrPNZRGCyD0/9YWpiwYSAWrJlRlfcGhdDo//dPtca5GMGeFuLxR5cc8bSuQ3rXPwvv6mBqtcVqCtQV+Dfr8BfZ6VurZP8obgAAAAASUVORK5CYII=",
        r =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAAXNSR0IArs4c6QAAAa5JREFUaAXtV1tywzAIdDq5Rg/Ui/SGzYl8j1brzqYYidHDYWw60g/iIWABKc6yGOsG+XdaSr/uFLe0dkZkNC25Wt6U7zq7C05zJMH9FofBd0IymZIKR4qYWAyh95LfbCgAxYLwd/e3h+yJm0YQWiurk2V4cXkzaALO5owKAJV7E7gsr9zzQBaBiirVXaV3KYeTbtDVyNOgUIFU9q+CeFj0bBs9sL/k5fhJnSXHOakbnzxmUKH3kl5m0JK1ZQ/fxQBHncqk3Uskg217mX2mHBC4I3APMAB6HglfgXQPXvqaZgXBRTu4PqTT+M+1+00uPtfW+94rRy/cEbgHKJYIY8pRGykLz/7jEkmIslwt8mSzSrtsbznMDBsF7lM0A1Q74V6iagbTYFZgVsC7Ani7sbzjjPrPPhu1o4skv6YPj3edG/jDAOQXjQxgAe+1p0/rXPhfgvAAih+9bJukVgtfNSq9/plb+A6EB9A8QmePCkdG0/AdCA+geYR068hbo0W9pr326Tz+p35qP+SbAVjPHB2dRcOP0ARw1ugwbvgOtFziR0J72T807MSkswKDFfgBlTxsE+QpCHoAAAAASUVORK5CYII=",
        s =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAQAAABIkb+zAAAC+0lEQVR4Ae2bA4xeURCFp7bdoGvjv3OC2m1Q24xW0cZJ3caqzdhJ3Vi1bdu2po1T3v95Nvu+E/N+z5hDMf4RExMTE4N0HmkqsZS34RAu4iG+8kd+hEs4xNuw1FTySKSTRvIbYyLW4xbEHr7JG8z47CakBVOMlXgHcRZ+w6tRSNGCOmY874e4D+83E1CHoqCwBWbzI4gPuY85hS0oVGrwDDyD+JgnZibVoHDgXByCBJBDnBvG8kfiPSSgvOfBFCg1sRASbHhRYIdSSn3eDgk+vD2lPvlPfks+AgknfCS/pd8XzTRchYSYq4Vp5B/ogNuQkHPbdPTv4LkMiSCXclr5curiOCSinMivS17hZZAIs5S8YfpDIs5Ack9OKzyJWoAfozW5BVsgCrKF3GG6QHQk0ZVcUBsXIe5Dv+FJ4aKLlx6UQtQICEodb3++qUmAb1BtcgJPh2gSgGAaOQEX1QlcouQxPSHqBMT0dH791yDg/H5Q1Ig/qhT4UNSIksGMgqgUEDPK+fOnKgFeRsmAM1oFcCap9y+IWgFJ4mXf9NMsYPqRDZRpFkCZXWCJaoElZIP3aBbgPWQDp50v0D2OBU+TDb6pWYBv2gWeqxZ4bhf4rlrgm13gk2qBT2QDTzUL4CnZ4BuaBfhGNbiM6r6R7SYbWFrVHyUqNAtwOdnAQM0CiQFkI7uJZoH8xmSHT2kV4FOUDFiqVQBLq8dnlaJG+KBRgD8WNaLkwGaVApsoWbiHSoEe1eDzuuIfHDzd6S+me6oE7lNtcgZXaBLgchczoZp+s1Jtck6iK0RHTJdqOWrwE7Tmx5CI8wStyT0YGLWA6V+lB554mR8jZ8ciEzjmywRpTitcUj30Z8d0VD52aSeREvbgayIlHj3+83TmbaEsf1tK/eCaG4uUj9/bSQzDO9UFCDucy/sC2fb7ODe8EtB0/0tA4dew5uivYdlfeibyAW9FOJ6EOpFXEXk1v1VeRbR/0zYTHJdBNZLI/KOO+4kf4RIfDqKOGxMTExMT8wNOZdb6YlKT2wAAAABJRU5ErkJggg==",
        c =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAQAAABIkb+zAAAC+0lEQVR4Ae2bA4xeURCFp7bdoGvjv3OC2m1Q24xW0cZJ3caqzdhJ3Vi1bdu2po1T3v95Nvu+E/N+z5hDMf4RExMTE4N0HmkqsZS34RAu4iG+8kd+hEs4xNuw1FTySKSTRvIbYyLW4xbEHr7JG8z47CakBVOMlXgHcRZ+w6tRSNGCOmY874e4D+83E1CHoqCwBWbzI4gPuY85hS0oVGrwDDyD+JgnZibVoHDgXByCBJBDnBvG8kfiPSSgvOfBFCg1sRASbHhRYIdSSn3eDgk+vD2lPvlPfks+AgknfCS/pd8XzTRchYSYq4Vp5B/ogNuQkHPbdPTv4LkMiSCXclr5curiOCSinMivS17hZZAIs5S8YfpDIs5Ack9OKzyJWoAfozW5BVsgCrKF3GG6QHQk0ZVcUBsXIe5Dv+FJ4aKLlx6UQtQICEodb3++qUmAb1BtcgJPh2gSgGAaOQEX1QlcouQxPSHqBMT0dH791yDg/H5Q1Ig/qhT4UNSIksGMgqgUEDPK+fOnKgFeRsmAM1oFcCap9y+IWgFJ4mXf9NMsYPqRDZRpFkCZXWCJaoElZIP3aBbgPWQDp50v0D2OBU+TDb6pWYBv2gWeqxZ4bhf4rlrgm13gk2qBT2QDTzUL4CnZ4BuaBfhGNbiM6r6R7SYbWFrVHyUqNAtwOdnAQM0CiQFkI7uJZoH8xmSHT2kV4FOUDFiqVQBLq8dnlaJG+KBRgD8WNaLkwGaVApsoWbiHSoEe1eDzuuIfHDzd6S+me6oE7lNtcgZXaBLgchczoZp+s1Jtck6iK0RHTJdqOWrwE7Tmx5CI8wStyT0YGLWA6V+lB554mR8jZ8ciEzjmywRpTitcUj30Z8d0VD52aSeREvbgayIlHj3+83TmbaEsf1tK/eCaG4uUj9/bSQzDO9UFCDucy/sC2fb7ODe8EtB0/0tA4dew5uivYdlfeibyAW9FOJ6EOpFXEXk1v1VeRbR/0zYTHJdBNZLI/KOO+4kf4RIfDqKOGxMTExMT8wNOZdb6YlKT2wAAAABJRU5ErkJggg==",
        u =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAQAAABIkb+zAAAC6ElEQVR4Ae2bA6weURCFp7bd4NnaOyeo3Qa1zaiKXpzUbazajJ3UjVXbtm1rGqO6u/sv5uXf74t91nfvHEpISEhISAgO5PAwU4nlvANHcBmP8Z0/8xNcwRHegeWmkochhzRS0hDjsBF3IHb5Nm8yYwoakRZMBVbjA8Sb/I7XooziBbXMGD4I8S8fNGNRi+KgrBnm8hNIAD7EvLJmFCnVeCpeQAL0mZlG1SgauAhHICF4hIsofHgYPkJC8iMPoFCpjsWQcOUloV1KmXV5JyR8eWdmXQqekuZ8DBKNfKykOQVLWTauQyL0elk2BQfa4S4kYu+a9sFdPFchMXilsEUgty5OQmLyVEltShVeAYnR5ZQapg8kZvuRfwpb4FncAfgpWpJfsA2iwG3kD9MRokOnE/mgJi5DlHjZx6IHMyCKnOH5+PNtTQH4FtUkL/AUiDInkxdwWV2AK+Qe0w2iT9NN//M/mPdBeQP+rDLAp/IG5AYzHKJTM1z796dFXkFuwDmIUs+5Wn9B9OpisW96aw5gepMNzIQodqY9wDLVAZaRDd6nOQDvIxs4C3EjBYzLCGfJBt/WHIBv2wO8VB3gpT3AT9UBftgDfFEd4AvZwHPNAfCcbPAtzQH4Vho8RnW/yPaSDSyv6p8SszUH4FlkA/00B3D6ko2CRqoXNA3JDp+B6JTPkAXtt/Hy9PitUt4AnyD65M/lDcgd2KoywBZyC3dVGaBrGvxeV7zBwVO8bjE9UBXgIdUkb/Bs7d9AFlBL0zYr1STvOJ20BDAd03PUgAgt+SkkZp9Zhj20rw5Mnyo98MQrghg5OxFbgBOBTJAWtsAV7UN/Fkx7/WOXFpzMqAdfncxk9Pgvw987IOHLOzLrhtfcWKJ//N6CMxgftBcgLHARHwjl2B/gouhKQFOCLwFFX8Oap7+GZV/0jONDqRXheDxqxV5F5LX8XnkV0f5P24xVXAZ1j5P3Rx33Cz/BFT4aRh03ISEhISHhF9FSCRjypNzcAAAAAElFTkSuQmCC";
    },
    3365: function (e, t, o) {
      var i = o(48059),
        a = o(2776),
        l = o(86229);
      (window.Blockly.Blocks.procedures_defnoreturn = {
        init() {
          (this.arguments = []),
            (this.argument_var_models = []),
            (this.is_adding = !1),
            this.timeout_id,
            this.jsonInit(this.definition()),
            window.Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT &&
              this.setCommentText(
                window.Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT
              ),
            this.getField("NAME").setValidator(
              window.Blockly.Procedures.rename
            );
          let e = new window.Blockly.FieldImage(l.dK, 24, 24, "+", () =>
              this.onAddClick()
            ),
            t = `${this.workspace.options.pathToMedia}dropdown-arrow.svg`,
            o = new window.Blockly.FieldImage(
              t,
              16,
              16,
              "v",
              () => this.toggleCollapseWithDelay(!0),
              !1,
              !0
            );
          this.appendDummyInput("ADD_ICON").appendField(e),
            this.appendDummyInput("COLLAPSED_INPUT").appendField(o),
            this.setStatements(!0);
        },
        definition: () => ({
          message0: (0, i.NC)(
            "function {{ function_name }} {{ function_params }}",
            { function_name: "%1", function_params: "%2" }
          ),
          args0: [
            { type: "field_input", name: "NAME", text: "" },
            { type: "field_label", name: "PARAMS", text: "" },
          ],
          inputsInline: !0,
          colour: window.Blockly.Colours.Special2.colour,
          colourSecondary: window.Blockly.Colours.Special2.colourSecondary,
          colourTertiary: window.Blockly.Colours.Special2.colourTertiary,
          tooltip: (0, i.NC)("Function with no return value"),
          category: window.Blockly.Categories.Functions,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Function"),
          description: (0, i.NC)(
            "This block creates a function, which is a group of instructions that can be executed at any time. Place other blocks in here to perform any kind of action that you need in your strategy. When all the instructions in a function have been carried out, your bot will continue with the remaining blocks in your strategy. Click the “do something” field to give it a name of your choice. Click the plus icon to send a value (as a named variable) to your function."
          ),
        }),
        onchange(e) {
          let t = [
            window.Blockly.Events.BLOCK_DELETE,
            window.Blockly.Events.BLOCK_CREATE,
            window.Blockly.Events.BLOCK_CHANGE,
          ];
          this.workspace &&
            !window.Blockly.derivWorkspace.isFlyoutVisible &&
            t.includes(e.type) &&
            (e.type === window.Blockly.Events.BLOCK_CREATE ||
              window.Blockly.Events.BLOCK_CHANGE) &&
            (e.blockId === this.id &&
              "NAME" === e.name &&
              this.getProcedureCallers().forEach((t) => {
                t.setFieldValue(e.newValue, "NAME");
              }),
            (0, a.TU)(this));
        },
        onAddClick() {
          !this.is_adding &&
            !this.workspace.options.readOnly &&
            !window.Blockly.derivWorkspace.isFlyoutVisible &&
            ((this.is_adding = !0),
            clearTimeout(this.timeout_id),
            (this.timeout_id = setTimeout(() => {
              let e = (0, i.NC)("Specify a parameter name:");
              window.Blockly.dialog.prompt(e, "", (e) => {
                if (e) {
                  let t = window.Blockly.Variables.getOrCreateVariablePackage(
                    this.workspace,
                    null,
                    e,
                    ""
                  );
                  t &&
                    (this.arguments.push(e),
                    this.argument_var_models.push(t),
                    this.getField("PARAMS").setText(
                      `${(0, i.NC)("with: ")} ${this.arguments.join(", ")}`
                    ),
                    this.getProcedureCallers().forEach((e) => {
                      e.setProcedureParameters(this.arguments),
                        e.initSvg(),
                        e.renderEfficiently();
                    }));
                }
                this.is_adding = !1;
              });
            }, 0)));
        },
        setStatements(e) {
          this.hasStatements !== e &&
            (e
              ? (this.appendStatementInput("STACK").appendField(""),
                this.getInput("RETURN") &&
                  this.moveInputBefore("STACK", "RETURN"))
              : this.removeInput("STACK", !0),
            (this.hasStatements = e));
        },
        updateParams() {
          let e = "";
          this.arguments.length &&
            (e = `${(0, i.NC)("with:")} ${this.arguments.join(", ")}`),
            window.Blockly.Events.disable();
          try {
            this.setFieldValue(e, "PARAMS");
          } finally {
            window.Blockly.Events.enable();
          }
        },
        mutationToDom(e) {
          let t = document.createElement("mutation");
          return (
            e && t.setAttribute("name", this.getFieldValue("NAME")),
            this.argument_var_models.forEach((o, i) => {
              let a = document.createElement("arg");
              a.setAttribute("name", o.name),
                a.setAttribute("varid", o.getId()),
                e &&
                  this.paramIds &&
                  a.setAttribute("paramId", this.paramIds[i]),
                t.appendChild(a);
            }),
            this.hasStatements || t.setAttribute("statements", "false"),
            t
          );
        },
        domToMutation(e) {
          (this.arguments = []),
            (this.argument_var_models = []),
            e.childNodes.forEach((e) => {
              if ("arg" === e.nodeName.toLowerCase()) {
                let t = e.getAttribute("name"),
                  o = e.getAttribute("varid") || e.getAttribute("varId"),
                  i = window.Blockly.Variables.getOrCreateVariablePackage(
                    this.workspace,
                    o,
                    t,
                    ""
                  );
                this.arguments.push(t),
                  null !== i
                    ? this.argument_var_models.push(i)
                    : console.log(
                        `Failed to create a variable with name ${t}, ignoring.`
                      );
              }
            }),
            this.updateParams(),
            this.setStatements("false" !== e.getAttribute("statements"));
        },
        getProcedureDef() {
          return [this.getFieldValue("NAME"), this.arguments, !1];
        },
        getProcedureCallers() {
          return this.workspace
            .getAllBlocks(!1)
            .filter((e) => e.type === this.callType && e.data === this.id);
        },
        getVars() {
          return this.arguments;
        },
        getVarModels() {
          return this.argument_var_models;
        },
        customContextMenu(e) {
          if (((0, a.Z3)(e), window.Blockly.derivWorkspace.isFlyoutVisible))
            return;
          let t = { enabled: !0 },
            o = this.getFieldValue("NAME");
          t.text = (0, i.NC)('Create "%1"').replace("%1", o);
          let l = document.createElement("mutation");
          l.setAttribute("name", o),
            this.arguments.forEach((e) => {
              let t = document.createElement("arg");
              t.setAttribute("name", e), l.appendChild(t);
            });
          let n = document.createElement("block");
          n.setAttribute("type", this.callType),
            n.appendChild(l),
            (t.callback = window.Blockly.ContextMenu.callbackFactory(this, n)),
            e.push(t),
            this.isCollapsed() ||
              this.argument_var_models.forEach((t) => {
                let o = { enabled: !0 };
                o.text = (0, i.NC)('Create "get %1"').replace("%1", t.name);
                let a = window.Blockly.Variables.generateVariableFieldDom(t),
                  l = document.createElement("block");
                l.setAttribute("type", "variables_get"),
                  l.appendChild(a),
                  (o.callback = window.Blockly.ContextMenu.callbackFactory(
                    this,
                    l
                  )),
                  e.push(o);
              });
        },
        callType: "procedures_callnoreturn",
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.procedures_defnoreturn =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("NAME"),
                window.Blockly.Procedures.CATEGORY_NAME
              ),
              o = window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "STACK"
              );
            if (window.Blockly.JavaScript.STATEMENT_PREFIX) {
              let t = e.id.replace(/\$/g, "$$$$");
              o =
                window.Blockly.JavaScript.prefixLines(
                  window.Blockly.JavaScript.STATEMENT_PREFIX.replace(
                    /%1/g,
                    `'${t}'`
                  ),
                  window.Blockly.JavaScript.INDENT
                ) + o;
            }
            window.Blockly.JavaScript.INFINITE_LOOP_TRAP &&
              (o =
                window.Blockly.JavaScript.INFINITE_LOOP_TRAP.replace(
                  /%1/g,
                  `'${e.id}'`
                ) + o);
            let i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "RETURN",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "";
            i &&
              (i = `${window.Blockly.JavaScript.INDENT}return ${i};
`);
            let a = e.arguments.map((e) =>
                window.Blockly.JavaScript.variableDB_.getName(
                  e,
                  window.Blockly.Variables.CATEGORY_NAME
                )
              ),
              l = window.Blockly.JavaScript.javascriptGenerator.scrub_(
                e,
                `
    function ${t}(${a.join(", ")}) {
        ${o}
        ${i}
    }
`
              );
            return (
              (window.Blockly.JavaScript.javascriptGenerator.definitions_[
                `%${t}`
              ] = l),
              null
            );
          }),
        (window.Blockly.Blocks.procedures_defreturn = {
          init() {
            (this.arguments = []),
              (this.argument_var_models = []),
              this.jsonInit(this.definition()),
              window.Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT &&
                this.setCommentText(
                  window.Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT
                ),
              this.getField("NAME").setValidator(
                window.Blockly.Procedures.rename
              );
            let e = new window.Blockly.FieldImage(l.M8, 24, 24, "+", () =>
                this.onAddClick()
              ),
              t = `${this.workspace.options.pathToMedia}dropdown-arrow.svg`,
              o = new window.Blockly.FieldImage(
                t,
                16,
                16,
                "v",
                () => this.toggleCollapseWithDelay(!0),
                !1,
                !0
              );
            this.appendDummyInput("ADD_ICON").appendField(e),
              this.moveInputBefore("ADD_ICON", "RETURN"),
              this.appendDummyInput("COLLAPSED_INPUT").appendField(o),
              this.moveInputBefore("COLLAPSED_INPUT", "RETURN"),
              this.setStatements(!0);
          },
          definition: () => ({
            message0: (0, i.NC)(
              "function {{ function_name }} {{ function_params }} {{ dummy }}",
              { function_name: "%1", function_params: "%2", dummy: "%3" }
            ),
            message1: "return %1",
            args0: [
              { type: "field_input", name: "NAME", text: "" },
              { type: "field_label", name: "PARAMS", text: "" },
              { type: "input_dummy" },
            ],
            args1: [{ type: "input_value", name: "RETURN", check: null }],
            inputsInline: !0,
            colour: window.Blockly.Colours.Special2.colour,
            colourSecondary: window.Blockly.Colours.Special2.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special2.colourTertiary,
            tooltip: (0, i.NC)("Function that returns a value"),
            category: window.Blockly.Categories.Functions,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Function that returns a value"),
            description: (0, i.NC)(
              "This block is similar to the one above, except that this returns a value. The returned value can be assigned to a variable of your choice."
            ),
          }),
          onAddClick: window.Blockly.Blocks.procedures_defnoreturn.onAddClick,
          onchange: window.Blockly.Blocks.procedures_defnoreturn.onchange,
          setStatements:
            window.Blockly.Blocks.procedures_defnoreturn.setStatements,
          updateParams:
            window.Blockly.Blocks.procedures_defnoreturn.updateParams,
          mutationToDom:
            window.Blockly.Blocks.procedures_defnoreturn.mutationToDom,
          domToMutation:
            window.Blockly.Blocks.procedures_defnoreturn.domToMutation,
          getProcedureDef() {
            return [this.getFieldValue("NAME"), this.arguments, !0];
          },
          getProcedureCallers:
            window.Blockly.Blocks.procedures_defnoreturn.getProcedureCallers,
          getVars: window.Blockly.Blocks.procedures_defnoreturn.getVars,
          getVarModels:
            window.Blockly.Blocks.procedures_defnoreturn.getVarModels,
          renameVarById:
            window.Blockly.Blocks.procedures_defnoreturn.renameVarById,
          displayRenamedVar:
            window.Blockly.Blocks.procedures_defnoreturn.displayRenamedVar,
          customContextMenu:
            window.Blockly.Blocks.procedures_defnoreturn.customContextMenu,
          registerWorkspaceListener:
            window.Blockly.Blocks.procedures_defnoreturn
              .registerWorkspaceListener,
          callType: "procedures_callreturn",
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.procedures_defreturn =
          window.Blockly.JavaScript.javascriptGenerator.forBlock.procedures_defnoreturn),
        (window.Blockly.Blocks.procedures_callnoreturn = {
          init() {
            (this.arguments = []),
              (this.argument_var_models = []),
              (this.previousDisabledState = !1),
              this.jsonInit(this.definition());
          },
          definition() {
            return {
              message0: "%1 %2",
              args0: [
                { type: "field_label", name: "NAME", text: this.id },
                { type: "input_dummy", name: "TOPROW" },
              ],
              inputsInline: !0,
              colour: window.Blockly.Colours.Special2.colour,
              colourSecondary: window.Blockly.Colours.Special2.colourSecondary,
              colourTertiary: window.Blockly.Colours.Special2.colourTertiary,
              previousStatement: null,
              nextStatement: null,
              tooltip: (0, i.NC)("Custom function"),
              category: window.Blockly.Categories.Functions,
            };
          },
          meta: () => ({
            display_name: (0, i.NC)("Custom function"),
            description: "",
          }),
          onchange(e) {
            if (
              this.workspace &&
              !window.Blockly.derivWorkspace.isFlyoutVisible &&
              e.recordUndo
            ) {
              if (
                e.type === window.Blockly.Events.BLOCK_CREATE &&
                -1 !== e.ids.indexOf(this.id)
              ) {
                let t = this.getProcedureCall(),
                  o = window.Blockly.Procedures.getDefinition(
                    t,
                    this.workspace
                  );
                if (
                  (o &&
                    (o.type !== this.defType ||
                      JSON.stringify(o.arguments) !==
                        JSON.stringify(this.arguments)) &&
                    (o = null),
                  o)
                ) {
                  this.data = o.id;
                  return;
                }
                window.Blockly.Events.setGroup(e.group);
                let i = document.createElement("xml"),
                  a = document.createElement("block");
                a.setAttribute("type", this.defType);
                let l = this.getRelativeToSurfaceXY(),
                  n = l.x + window.Blockly.SNAP_RADIUS * (this.RTL ? -1 : 1),
                  r = l.y + 2 * window.Blockly.SNAP_RADIUS;
                a.setAttribute("x", n), a.setAttribute("y", r);
                let s = this.mutationToDom();
                a.appendChild(s);
                let c = document.createElement("field");
                c.setAttribute("name", "NAME"),
                  c.appendChild(
                    document.createTextNode(this.getProcedureCall())
                  ),
                  a.appendChild(c),
                  i.appendChild(a),
                  window.Blockly.Xml.domToWorkspace(i, this.workspace),
                  window.Blockly.Events.setGroup(!1);
                let u = window.Blockly.Procedures.getDefinition(
                  t,
                  this.workspace
                );
                this.data = u.id;
              } else if (e.type === window.Blockly.Events.BLOCK_DELETE) {
                let t = this.getProcedureCall();
                window.Blockly.Procedures.getDefinition(t, this.workspace) ||
                  (window.Blockly.Events.setGroup(e.group),
                  this.dispose(!0, !1),
                  window.Blockly.Events.setGroup(!1));
              } else if (
                e.type === window.Blockly.Events.BLOCK_CHANGE &&
                "disabled" === e.element
              ) {
                let t = this.getProcedureCall(),
                  o = window.Blockly.Procedures.getDefinition(
                    t,
                    this.workspace
                  );
                if (o && o.id === e.blockId) {
                  let t = window.Blockly.Events.getGroup();
                  t &&
                    console.log(
                      "Saw an existing group while responding to a definition change"
                    ),
                    window.Blockly.Events.setGroup(e.group),
                    e.newValue
                      ? ((this.previousDisabledState = this.disabled),
                        this.setDisabled(!0))
                      : this.setDisabled(this.previousDisabledState),
                    window.Blockly.Events.setGroup(t);
                }
              }
            }
          },
          getProcedureDefinition(e) {
            return this.workspace.getTopBlocks(!1).find((t) => {
              if (t.getProcedureDef) {
                let o = t.getProcedureDef();
                return o && window.Blockly.Names.equals(o[0], e);
              }
              return !1;
            });
          },
          getProcedureCall() {
            return this.getFieldValue("NAME");
          },
          renameProcedure(e, t) {
            window.Blockly.Names.equals(e, this.getProcedureCall()) &&
              this.setFieldValue(t, "NAME");
          },
          setProcedureParameters(e) {
            (this.arguments = [].concat(e)),
              (this.argument_var_models = this.arguments.map((e) =>
                window.Blockly.Variables.getOrCreateVariablePackage(
                  this.workspace,
                  null,
                  e,
                  ""
                )
              )),
              this.updateShape();
          },
          updateShape() {
            this.arguments.forEach((e, t) => {
              let o = this.getField(`ARGNAME${t}`);
              if (o) {
                window.Blockly.Events.disable();
                try {
                  o.setValue(e);
                } finally {
                  window.Blockly.Events.enable();
                }
              } else
                (o = new window.Blockly.FieldLabel(e)),
                  this.appendValueInput(`ARG${t}`)
                    .appendField(o, `ARGNAME${t}`)
                    .init();
            });
            let e = this.arguments.length;
            for (; this.getInput(`ARG${e}`); ) this.removeInput(`ARG${e}`), e++;
            let t = this.getInput("TOPROW");
            t &&
              (this.arguments.length
                ? this.getField("WITH") ||
                  (t.appendField((0, i.NC)("with:"), "WITH"), t.init())
                : this.getField("WITH") && t.removeField("WITH"));
          },
          mutationToDom() {
            let e = document.createElement("mutation");
            return (
              e.setAttribute("name", this.getProcedureCall()),
              this.arguments.forEach((t) => {
                let o = document.createElement("arg");
                o.setAttribute("name", t), e.appendChild(o);
              }),
              e
            );
          },
          domToMutation(e) {
            let t = e.getAttribute("name");
            this.renameProcedure(this.getProcedureCall(), t);
            let o = [],
              i = [];
            e.childNodes.forEach((e) => {
              "arg" === e.nodeName.toLowerCase() &&
                (o.push(e.getAttribute("name")),
                i.push(e.getAttribute("paramId")));
            }),
              this.setProcedureParameters(o, i);
          },
          getVarModels() {
            return this.argument_var_models;
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
            let t = this.getProcedureCall(),
              { workspace: o } = this,
              l = { enabled: !0 };
            (l.text = (0, i.NC)("Highlight function definition")),
              (l.callback = () => {
                let e = this.getProcedureDefinition(t);
                e && (o.centerOnBlock(e.id), e.select());
              }),
              e.push(l);
          },
          defType: "procedures_defnoreturn",
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.procedures_callnoreturn =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("NAME"),
                window.Blockly.Procedures.CATEGORY_NAME
              ),
              o = e.arguments.map(
                (t, o) =>
                  window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    `ARG${o}`,
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                  ) || "null"
              );
            return `${t}(${o.join(", ")});
`;
          }),
        (window.Blockly.Blocks.procedures_callreturn = {
          init() {
            (this.arguments = []),
              (this.previousDisabledState = !1),
              this.jsonInit(this.definition());
          },
          definition() {
            return {
              message0: "%1 %2",
              args0: [
                { type: "field_label", name: "NAME", text: this.id },
                { type: "input_dummy", name: "TOPROW" },
              ],
              output: null,
              outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
              colour: window.Blockly.Colours.Special2.colour,
              colourSecondary: window.Blockly.Colours.Special2.colourSecondary,
              colourTertiary: window.Blockly.Colours.Special2.colourTertiary,
              tooltip: (0, i.NC)("Custom function"),
              category: window.Blockly.Categories.Functions,
              inputsInline: !0,
            };
          },
          meta: () => ({
            display_name: (0, i.NC)("Custom function"),
            description: "",
          }),
          onchange: window.Blockly.Blocks.procedures_callnoreturn.onchange,
          getProcedureDefinition:
            window.Blockly.Blocks.procedures_callnoreturn
              .getProcedureDefinition,
          getProcedureCall:
            window.Blockly.Blocks.procedures_callnoreturn.getProcedureCall,
          renameProcedure:
            window.Blockly.Blocks.procedures_callnoreturn.renameProcedure,
          setProcedureParameters:
            window.Blockly.Blocks.procedures_callnoreturn
              .setProcedureParameters,
          updateShape:
            window.Blockly.Blocks.procedures_callnoreturn.updateShape,
          mutationToDom:
            window.Blockly.Blocks.procedures_callnoreturn.mutationToDom,
          domToMutation:
            window.Blockly.Blocks.procedures_callnoreturn.domToMutation,
          getVarModels:
            window.Blockly.Blocks.procedures_callnoreturn.getVarModels,
          customContextMenu:
            window.Blockly.Blocks.procedures_callnoreturn.customContextMenu,
          defType: "procedures_defreturn",
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.procedures_callreturn =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("NAME"),
                window.Blockly.Procedures.CATEGORY_NAME
              ),
              o = e.arguments.map(
                (t, o) =>
                  window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    `ARG${o}`,
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                  ) || "null"
              );
            return [
              `${t}(${o.join(", ")})`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ];
          }),
        (window.Blockly.Blocks.procedures_ifreturn = {
          init() {
            (this.hasReturnValue = !0), this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("if {{ condition }} return {{ value }}", {
              condition: "%1",
              value: "%2",
            }),
            args0: [
              { type: "input_value", name: "CONDITION" },
              { type: "input_value", name: "VALUE" },
            ],
            inputsInline: !0,
            colour: window.Blockly.Colours.Special2.colour,
            colourSecondary: window.Blockly.Colours.Special2.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special2.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Prematurely returns a value within a function"),
            category: window.Blockly.Categories.Functions,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Conditional return"),
            description: (0, i.NC)(
              "This block returns a value when a condition is true. Use this block within either of the function blocks above."
            ),
          }),
          mutationToDom() {
            let e = document.createElement("mutation");
            return e.setAttribute("value", Number(this.hasReturnValue)), e;
          },
          domToMutation(e) {
            let t = e.getAttribute("value");
            (this.hasReturnValue = "1" === t),
              this.hasReturnValue ||
                (this.removeInput("VALUE"),
                this.appendDummyInput("VALUE").appendField((0, i.NC)("return")),
                this.initSvg(),
                this.renderEfficiently());
          },
          onchange() {
            if (!this.workspace.isDragging || this.workspace.isDragging())
              return;
            let e = !1,
              t = this;
            do {
              if (-1 !== this.FUNCTION_TYPES.indexOf(t.type)) {
                e = !0;
                break;
              }
              t = t.getSurroundParent();
            } while (t);
            if (e) {
              let e = () => {
                this.initSvg(), this.renderEfficiently();
              };
              "procedures_defnoreturn" === t.type && this.hasReturnValue
                ? (this.removeInput("VALUE"),
                  this.appendDummyInput("VALUE").appendField(
                    (0, i.NC)("return")
                  ),
                  e(),
                  (this.hasReturnValue = !1))
                : "procedures_defreturn" !== t.type ||
                  this.hasReturnValue ||
                  (this.removeInput("VALUE"),
                  this.appendValueInput("VALUE").appendField(
                    (0, i.NC)("return")
                  ),
                  e(),
                  (this.hasReturnValue = !0)),
                window.Blockly.derivWorkspace.isFlyoutVisible ||
                  this.setDisabled(!1);
            } else
              window.Blockly.derivWorkspace.isFlyoutVisible ||
                this.getInheritedDisabled() ||
                this.setDisabled(!0);
          },
          FUNCTION_TYPES: ["procedures_defnoreturn", "procedures_defreturn"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.procedures_ifreturn =
          (e) => {
            let t;
            let o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "CONDITION",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "false";
            if (e.hasReturnValue) {
              let o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "VALUE",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
                ) || "null";
              t = `return ${o};
`;
            } else t = "return;\n";
            return `
    if (${o}) {
        ${t}
    }
`;
          }),
        (window.Blockly.Blocks.lists_create_with = {
          protected_statements: ["STACK"],
          allowed_children: ["lists_statement"],
          init() {
            let e = new window.Blockly.FieldImage(
              l.M8,
              25,
              25,
              "",
              this.onIconClick.bind(this)
            );
            this.jsonInit(this.definition()),
              this.appendDummyInput("ADD_ICON").appendField(e),
              this.moveInputBefore("ADD_ICON", "STACK");
          },
          definition: () => ({
            message0: (0, i.NC)("set {{ variable }} to create list with", {
              variable: "%1",
            }),
            message1: "%1",
            args0: [
              {
                type: "field_variable",
                name: "VARIABLE",
                variable: (0, i.NC)("list"),
              },
            ],
            args1: [{ type: "input_statement", name: "STACK" }],
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "This block creates a list with strings and numbers."
            ),
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Create list"),
            description: (0, i.NC)(
              "This block creates a list with strings and numbers."
            ),
          }),
          onIconClick() {
            !this.workspace.options.readOnly &&
              !window.Blockly.derivWorkspace.isFlyoutVisible &&
              (0, a.UR)(!1, () => {
                let e = this.workspace.newBlock("lists_statement");
                (e.required_parent_id = this.id),
                  e.setMovable(!1),
                  e.initSvg(),
                  e.renderEfficiently(),
                  this.getLastConnectionInStatement("STACK").connect(
                    e.previousConnection
                  );
              });
          },
          onchange(e) {
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) &&
              (e.type !== window.Blockly.Events.BLOCK_DRAG ||
                e.isStart ||
                this.getBlocksInStatement("STACK").forEach((e) => {
                  this.allowed_children.includes(e.type) ||
                    (0, a.$9)(() => {
                      e.unplug(!1);
                    });
                }));
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_create_with =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.getBlocksInStatement("STACK").map((e) => {
                let t =
                  window.Blockly.JavaScript.javascriptGenerator.forBlock[
                    e.type
                  ](e);
                return Array.isArray(t) ? t[0] : t;
              });
            return `${t} = [${o.join(", ")}];
`;
          }),
        (window.Blockly.Blocks.lists_repeat = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "create list with item {{ input_item }} repeated {{ number }} times",
              { input_item: "%1", number: "%2" }
            ),
            args0: [
              { type: "input_value", name: "ITEM" },
              { type: "input_value", name: "NUM" },
            ],
            inputsInline: !0,
            output: null,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Creates a list by repeating a given item"),
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Repeat an item"),
            description: (0, i.NC)(
              "Creates a list with a given item repeated for a specific number of times."
            ),
          }),
          getRequiredValueInputs: () => ({ ITEM: a.cM, NUM: a.cM }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_repeat = (
          e
        ) => {
          let t =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "listsRepeat",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(value, n) {
            var array = [];
            for (var i = 0; i < n; i++) {
                array[i] = value;
            }
            return array;
        }`,
                ]
              ),
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "ITEM",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
              ) || "null",
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "NUM",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
              ) || "0";
          return [
            `${t}(${o}, ${i})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        }),
        (window.Blockly.Blocks.lists_length = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("length of {{ input_list }}", {
              input_list: "%1",
            }),
            args0: [{ type: "input_value", name: "VALUE" }],
            inputsInline: !0,
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you the total number of items in a given list."
            ),
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("List Length"),
            description: (0, i.NC)(
              "This block gives you the total number of items in a given list."
            ),
          }),
          getRequiredValueInputs: () => ({ VALUE: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_length = (
          e
        ) => {
          let t =
            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "VALUE",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
            ) || "[]";
          return [
            `${t}.length`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER,
          ];
        }),
        (window.Blockly.Blocks.lists_isEmpty = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("list {{ input_list }} is empty", {
              input_list: "%1",
            }),
            args0: [{ type: "input_value", name: "VALUE", check: ["Array"] }],
            inputsInline: !0,
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Checks if a given list is empty"),
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Is list empty?"),
            description: (0, i.NC)(
              "This block checks if a given list is empty. It returns “True” if the list is empty, “False” if otherwise."
            ),
          }),
          getRequiredValueInputs: () => ({ VALUE: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_isEmpty =
          (e) => {
            let t =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "VALUE",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
              ) || "[]";
            return [
              -1 !==
              e.workspace.getAllVariables().findIndex((e) => e.name === t)
                ? `!${t} || !${t}.length`
                : `!${t}.length`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_LOGICAL_NOT,
            ];
          }),
        (window.Blockly.Blocks.lists_indexOf = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "in list {{ input_list }} find {{ first_or_last }} occurence of item {{ input_value }}",
              { input_list: "%1", first_or_last: "%2", input_value: "%3" }
            ),
            args0: [
              { type: "input_value", name: "VALUE" },
              {
                type: "field_dropdown",
                name: "END",
                options: [
                  [(0, i.NC)("first"), "FIRST"],
                  [(0, i.NC)("last"), "LAST"],
                ],
              },
              { type: "input_value", name: "FIND" },
            ],
            output: "Number",
            inputsInline: !0,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you the position of an item in a given list."
            ),
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("List item position"),
            description: (0, i.NC)(
              "This block gives you the position of an item in a given list."
            ),
          }),
          getRequiredValueInputs: () => ({ VALUE: null, FIND: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_indexOf =
          (e) => {
            let t =
                "FIRST" === e.getFieldValue("END") ? "indexOf" : "lastIndexOf",
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "FIND",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
                ) || "''",
              i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "VALUE",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
                ) || "''",
              a = `${i}.${t}(${o})`;
            return e.workspace.options.oneBasedIndex
              ? [
                  `${a} + 1`,
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ADDITION,
                ]
              : [
                  a,
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_FUNCTION_CALL,
                ];
          }),
        (window.Blockly.Blocks.lists_getIndex = {
          init() {
            (this.MODE_OPTIONS = [
              [(0, i.NC)("get"), "GET"],
              [(0, i.NC)("get and remove"), "GET_REMOVE"],
              [(0, i.NC)("remove"), "REMOVE"],
            ]),
              (this.WHERE_OPTIONS = [
                ["#", "FROM_START"],
                [(0, i.NC)("# from end"), "FROM_END"],
                [(0, i.NC)("first"), "FIRST"],
                [(0, i.NC)("last"), "LAST"],
                [(0, i.NC)("random"), "RANDOM"],
              ]);
            let e = new window.Blockly.FieldDropdown(this.MODE_OPTIONS, (e) => {
              this.updateStatement("REMOVE" === e);
            });
            this.appendValueInput("VALUE")
              .setCheck("Array")
              .appendField((0, i.NC)("in list")),
              this.appendDummyInput().appendField(e, "MODE"),
              this.appendDummyInput("AT");
            let t =
              window.Blockly.Colours.Base.colour ||
              window.Blockly.Colours.Base.colourSecondary ||
              window.Blockly.Colours.Base.colourTertiary;
            this.setColour(t),
              this.setTooltip(
                "This block gives you the value of a specific item in a list, given the position of the item. It can also remove the item from the list."
              ),
              this.setInputsInline(!0),
              this.setOutput(!0, null),
              this.setOutputShape(window.Blockly.OUTPUT_SHAPE_ROUND),
              this.updateAt(!0);
          },
          meta: () => ({
            display_name: (0, i.NC)("Get list item"),
            description: (0, i.NC)(
              "This block gives you the value of a specific item in a list, given the position of the item. It can also remove the item from the list."
            ),
            category: window.Blockly.Categories.List,
          }),
          mutationToDom() {
            let e = document.createElement("mutation"),
              t = !this.outputConnection,
              o = this.getInput("AT").type === window.Blockly.INPUT_VALUE;
            return e.setAttribute("statement", t), e.setAttribute("at", o), e;
          },
          domToMutation(e) {
            let t = "true" === e.getAttribute("statement");
            this.updateStatement(t);
            let o = "false" !== e.getAttribute("at");
            this.updateAt(o);
          },
          updateStatement(e) {
            !this.outputConnection !== e &&
              (this.unplug(!0, !0),
              this.setOutput(!e),
              this.setPreviousStatement(e),
              this.setNextStatement(e),
              this.initSvg());
          },
          updateAt(e) {
            this.removeInput("AT", !0),
              e
                ? this.appendValueInput("AT").setCheck("Number")
                : this.appendDummyInput("AT");
            let t = new window.Blockly.FieldDropdown(
              this.WHERE_OPTIONS,
              (t) => {
                let o = ["FROM_START", "FROM_END"].includes(t);
                if (o !== e)
                  return this.updateAt(o), this.setFieldValue(t, "WHERE"), null;
              }
            );
            this.getInput("AT").appendField(t, "WHERE"), this.initSvg();
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_getIndex =
          (e) => {
            let t, o;
            let i = e.getFieldValue("MODE") || "GET",
              a = e.getFieldValue("WHERE") || "FIRST",
              l =
                "RANDOM" === a
                  ? window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                  : window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER,
              n =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "VALUE",
                  l
                ) || "[]";
            if ("FIRST" === a) {
              if ("GET" === i)
                (t = `${n}[0]`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER);
              else if ("GET_REMOVE" === i)
                (t = `${n}.shift()`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER);
              else if ("REMOVE" === i)
                return `${n}.shift();
`;
            } else if ("LAST" === a) {
              if ("GET" === i)
                (t = `${n}.slice(-1)[0]`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER);
              else if ("GET_REMOVE" === i)
                (t = `${n}.pop()`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER);
              else if ("REMOVE" === i)
                return `${n}.pop();
`;
            } else if ("FROM_START" === a) {
              let a = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                e,
                "AT"
              );
              if ("GET" === i)
                (t = `${n}[${a}]`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER);
              else if ("GET_REMOVE" === i)
                (t = `${n}.splice(${a}, 1)[0]`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator
                      .ORDER_FUNCTION_CALL);
              else if ("REMOVE" === i)
                return `${n}.splice(${a}, 1);
`;
            } else if ("FROM_END" === a) {
              let a = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                e,
                "AT",
                1,
                !0
              );
              if ("GET" === i)
                (t = `${n}.slice(${a})[0]`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator
                      .ORDER_FUNCTION_CALL);
              else if ("GET_REMOVE" === i)
                (t = `${n}.splice(${a}, 1)[0]`),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator
                      .ORDER_FUNCTION_CALL);
              else if ("REMOVE" === i)
                return `${n}.splice(${a}, 1);
`;
            } else if ("RANDOM" === a) {
              let e =
                window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                  "listsGetRandomItem",
                  [
                    `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(list, remove) {
                var x = Math.floor(Math.random() * list.length);
                if (remove) {
                    return list.splice(x, 1)[0];
                } else {
                    return list[x];
                }
            }`,
                  ]
                );
              if (
                ((t = `${e}(${n}, ${"GET" !== i})`),
                "GET" === i || "GET_REMOVE" === i)
              )
                o =
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_FUNCTION_CALL;
              else if ("REMOVE" === i)
                return `${t};
`;
            }
            return [t, o];
          }),
        (window.Blockly.Blocks.lists_setIndex = {
          init() {
            (this.MODE_OPTIONS = [
              [(0, i.NC)("set"), "SET"],
              [(0, i.NC)("insert at"), "INSERT"],
            ]),
              (this.WHERE_OPTIONS = [
                [(0, i.NC)("#"), "FROM_START"],
                [(0, i.NC)("# from end"), "FROM_END"],
                [(0, i.NC)("first"), "FIRST"],
                [(0, i.NC)("last"), "LAST"],
                [(0, i.NC)("random"), "RANDOM"],
              ]),
              this.appendValueInput("LIST")
                .setCheck("Array")
                .appendField((0, i.NC)("in list")),
              this.appendDummyInput().appendField(
                new window.Blockly.FieldDropdown(this.MODE_OPTIONS),
                "MODE"
              ),
              this.appendDummyInput("AT"),
              this.appendValueInput("TO").appendField((0, i.NC)("as"));
            let e =
              window.Blockly.Colours.Base.colour ||
              window.Blockly.Colours.Base.colourSecondary ||
              window.Blockly.Colours.Base.colourTertiary;
            this.setColour(e),
              this.setPreviousStatement(!0, null),
              this.setNextStatement(!0, null),
              this.setTooltip(
                (0, i.NC)(
                  "This block replaces a specific item in a list with another given item. It can also insert the new item in the list at a specific position."
                )
              ),
              this.updateAt(!0);
          },
          meta: () => ({
            display_name: (0, i.NC)("Set list item"),
            description: (0, i.NC)(
              "This block replaces a specific item in a list with another given item. It can also insert the new item in the list at a specific position."
            ),
            category: window.Blockly.Categories.List,
          }),
          mutationToDom() {
            let e = document.createElement("mutation"),
              t = this.getInput("AT").type === window.Blockly.INPUT_VALUE;
            return e.setAttribute("at", t), e;
          },
          domToMutation(e) {
            let t = "false" !== e.getAttribute("at");
            this.updateAt(t);
          },
          updateAt(e) {
            this.removeInput("AT", !0),
              e
                ? this.appendValueInput("AT").setCheck("Number")
                : this.appendDummyInput("AT");
            let t = new window.Blockly.FieldDropdown(
              this.WHERE_OPTIONS,
              (t) => {
                let o = ["FROM_START", "FROM_END"].includes(t);
                if (o !== e)
                  return this.updateAt(o), this.setFieldValue(t, "WHERE"), null;
              }
            );
            this.moveInputBefore("AT", "TO"),
              this.getInput("AT").appendField(t, "WHERE"),
              this.initSvg();
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_setIndex =
          (e) => {
            let t;
            let o = e.getFieldValue("MODE") || "SET",
              i = e.getFieldValue("WHERE") || "FIRST",
              a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TO",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ASSIGNMENT
                ) || "null",
              l =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "LIST",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
                ) || "[]",
              n = () => {
                if (l.match(/^\w+$/)) return "";
                let e = window.Blockly.JavaScript.variableDB_.getDistinctName(
                    "tmpList",
                    window.Blockly.Variables.CATEGORY_NAME
                  ),
                  t = `var ${e} = ${l};
`;
                return (l = e), t;
              };
            if ("FIRST" === i)
              "SET" === o
                ? (t = `${l}[0] = ${a};
`)
                : "INSERT" === o &&
                  (t = `${l}.unshift(${a});
`);
            else if ("LAST" === i)
              "SET" === o
                ? (t =
                    n() +
                    `${l}[${l}.length - 1] = ${a};
`)
                : "INSERT" === o &&
                  (t = `${l}.push(${a});
`);
            else if ("FROM_START" === i) {
              let i = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                e,
                "AT"
              );
              "SET" === o
                ? (t = `${l}[${i}] = ${a};
`)
                : "INSERT" === o &&
                  (t = `${l}.splice(${i}, 0, ${a});
`);
            } else if ("FROM_END" === i) {
              let i = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                e,
                "AT",
                1,
                !1,
                window.Blockly.JavaScript.javascriptGenerator.ORDER_SUBTRACTION
              );
              (t = n()),
                "SET" === o
                  ? (t = `${l}[${l}.length - ${i}] = ${a};
`)
                  : "INSERT" === o &&
                    (t = `${l}.splice(${l}.length - ${i}, 0, ${a});
`);
            } else if ("RANDOM" === i) {
              t = n();
              let e = window.Blockly.JavaScript.variableDB_.getDistinctName(
                "tmpX",
                window.Blockly.Variables.CATEGORY_NAME
              );
              (t += `var ${e} = Math.floor(Math.random() * ${l}.length);
`),
                "SET" === o
                  ? (t += `${l}[${e}] = ${a};
`)
                  : "INSERT" === o &&
                    (t += `${l}.splice(${e}, 0, ${a});
`);
            }
            return t;
          }),
        (window.Blockly.Blocks.lists_getSublist = {
          init() {
            (this.WHERE_OPTIONS_1 = [
              [(0, i.NC)("get sub-list from #"), "FROM_START"],
              [(0, i.NC)("get sub-list from # from end"), "FROM_END"],
              [(0, i.NC)("get sub-list from first"), "FIRST"],
            ]),
              (this.WHERE_OPTIONS_2 = [
                [(0, i.NC)("#"), "FROM_START"],
                [(0, i.NC)("# from end"), "FROM_END"],
                [(0, i.NC)("last"), "LAST"],
              ]),
              this.appendValueInput("LIST").appendField((0, i.NC)("in list")),
              this.appendDummyInput("AT1"),
              this.appendDummyInput("AT2");
            let e =
              window.Blockly.Colours.Base.colour ||
              window.Blockly.Colours.Base.colourSecondary ||
              window.Blockly.Colours.Base.colourTertiary;
            this.setColour(e),
              this.setOutput(!0, null),
              this.setOutputShape(window.Blockly.OUTPUT_SHAPE_ROUND),
              this.setInputsInline(!0),
              this.setTooltip(
                (0, i.NC)(
                  "This block creates a list of items from an existing list, using specific item positions."
                )
              ),
              this.updateAt(1, !0),
              this.updateAt(2, !0);
          },
          meta: () => ({
            display_name: (0, i.NC)("Get sub-list"),
            description: (0, i.NC)(
              "This block creates a list of items from an existing list, using specific item positions."
            ),
            category: window.Blockly.Categories.List,
          }),
          mutationToDom() {
            let e = document.createElement("mutation"),
              t = this.getInput("AT1").type === window.Blockly.INPUT_VALUE,
              o = this.getInput("AT2").type === window.Blockly.INPUT_VALUE;
            return e.setAttribute("at1", t), e.setAttribute("at2", o), e;
          },
          domToMutation(e) {
            let t = "true" === e.getAttribute("at1"),
              o = "true" === e.getAttribute("at2");
            this.updateAt(1, t), this.updateAt(2, o);
          },
          updateAt(e, t) {
            this.removeInput(`AT${e}`),
              t
                ? this.appendValueInput(`AT${e}`).setCheck("Number")
                : this.appendDummyInput(`AT${e}`);
            let o = new window.Blockly.FieldDropdown(
              this[`WHERE_OPTIONS_${e}`],
              (o) => {
                let i = ["FROM_START", "FROM_END"].includes(o);
                if (i !== t)
                  return (
                    this.updateAt(e, i),
                    this.setFieldValue(o, `WHERE${e}`),
                    null
                  );
              }
            );
            this.getInput(`AT${e}`).appendField(o, `WHERE${e}`),
              1 === e && this.moveInputBefore("AT1", "AT2"),
              this.initSvg(),
              this.renderEfficiently();
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_getSublist =
          (e) => {
            let t, o, i;
            let a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "LIST",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
                ) || "[]",
              l = e.getFieldValue("WHERE1"),
              n = e.getFieldValue("WHERE2");
            if ("FIRST" === l && "LAST" === n) i = `${a}.slice(0)`;
            else if (
              a.match(/^\w+$/) ||
              ("FROM_END" !== l && "FROM_START" === n)
            )
              "FROM_START" === l
                ? (t =
                    window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                      e,
                      "AT1"
                    ))
                : "FROM_END" === l
                ? ((t =
                    window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                      e,
                      "AT1",
                      1,
                      !1,
                      window.Blockly.JavaScript.javascriptGenerator
                        .ORDER_SUBTRACTION
                    )),
                  (t = `${a}.length - ${t}`))
                : "FIRST" === l && (t = "0"),
                "FROM_START" === n
                  ? (o =
                      window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                        e,
                        "AT2",
                        1
                      ))
                  : "FROM_END" === n
                  ? ((o =
                      window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                        e,
                        "AT2",
                        0,
                        !1,
                        window.Blockly.JavaScript.javascriptGenerator
                          .ORDER_SUBTRACTION
                      )),
                    (o = `${a}.length - ${o}`))
                  : "LAST" === n && (o = `${a}.length`),
                (i = `${a}.slice(${t}, ${o})`);
            else {
              (t = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                e,
                "AT1"
              )),
                (o = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                  e,
                  "AT2"
                ));
              let r = {
                  FROM_START: "FromStart",
                  FROM_END: "FromEnd",
                  FIRST: "First",
                  LAST: "Last",
                },
                s = (e, t, o) =>
                  "FIRST" === t
                    ? "0"
                    : "FROM_END" === t
                    ? `${e}.length - 1 - ${o}`
                    : "LAST" === t
                    ? `${e}.length - 1`
                    : `${o}`,
                c = "FROM_END" === l || "FROM_START" === l,
                u = "FROM_END" === n || "FROM_START" === n,
                d =
                  window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                    `subsequence${r[l]}${r[n]}`,
                    [
                      `function ${
                        window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_
                      }(
                    sequence${c ? ", at1" : ""}${u ? ", at2" : ""}
                ) {
                    var start = ${s("sequence", l, "at1")};
                    var end = ${s("sequence", n, "at2")} + 1;

                    return sequence.slice(start, end);
                }`,
                    ]
                  );
              i = `${d}(${a}${c ? `, ${t}` : ""}${u ? `, ${o}` : ""})`;
            }
            return [
              i,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ];
          }),
        (window.Blockly.Blocks.lists_split = {
          init() {
            let e = new window.Blockly.FieldDropdown(
              [
                [(0, i.NC)("make list from text"), "SPLIT"],
                [(0, i.NC)("make text from list"), "JOIN"],
              ],
              (e) => this.updateType(e)
            );
            this.appendValueInput("INPUT")
              .setCheck("String")
              .appendField(e, "MODE"),
              this.appendValueInput("DELIM")
                .setCheck("String")
                .appendField("", "SPACE1")
                .appendField((0, i.NC)("with delimiter"), "DELIM_LABEL"),
              this.appendDummyInput().appendField("", "SPACE2"),
              this.setOutput(!0, "Array"),
              this.setOutputShape(window.Blockly.OUTPUT_SHAPE_ROUND),
              this.setColour(window.Blockly.Colours.Base.colour),
              this.setTooltip(
                (0, i.NC)(
                  "This block creates a list from a given string of text, splitting it with the given delimiter. It can also join items in a list into a string of text."
                )
              );
          },
          meta: () => ({
            display_name: (0, i.NC)("Create list from text"),
            description: (0, i.NC)(
              "This block creates a list from a given string of text, splitting it with the given delimiter. It can also join items in a list into a string of text."
            ),
            category: window.Blockly.Categories.List,
          }),
          mutationToDom() {
            let e = document.createElement("mutation");
            return e.setAttribute("mode", this.getFieldValue("MODE")), e;
          },
          domToMutation(e) {
            this.updateType(e.getAttribute("mode"));
          },
          updateType(e) {
            let t = this.getInput("DELIM"),
              o = this.getField("SPACE1");
            "SPLIT" === e
              ? (this.outputConnection.setCheck("Array"),
                this.getInput("INPUT").setCheck("String"),
                o || t.insertFieldAt(0, "", "SPACE1"))
              : (this.outputConnection.setCheck("String"),
                this.getInput("INPUT").setCheck(null),
                o && t.removeField("SPACE1")),
              this.initSvg(),
              this.renderEfficiently();
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_split = (
          e
        ) => {
          let t;
          let o = window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "INPUT",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
            ),
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "DELIM",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "''",
            a = e.getFieldValue("MODE");
          return (
            "SPLIT" === a
              ? (t = `${o || "''"}.split(${i})`)
              : "JOIN" === a && (t = `${o || "[]"}.join(${i})`),
            [
              t,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ]
          );
        }),
        (window.Blockly.Blocks.lists_sort = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "sort {{ sort_type }} {{ sort_direction }} {{ input_list }}",
              { sort_type: "%1", sort_direction: "%2", input_list: "%3" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "TYPE",
                options: [
                  [(0, i.NC)("numeric"), "NUMERIC"],
                  [(0, i.NC)("alphabetic"), "TEXT"],
                ],
              },
              {
                type: "field_dropdown",
                name: "DIRECTION",
                options: [
                  [(0, i.NC)("ascending"), "1"],
                  [(0, i.NC)("descending"), "-1"],
                ],
              },
              { type: "input_value", name: "LIST" },
            ],
            inputsInline: !0,
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Sorts the items in a given list"),
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Sort list"),
            description: (0, i.NC)(
              "Sorts the items in a given list, by their numeric or alphabetical value, in either ascending or descending order."
            ),
          }),
          getRequiredValueInputs: () => ({ LIST: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_sort = (
          e
        ) => {
          let t =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator
                  .ORDER_FUNCTION_CALL
              ) || "[]",
            o = "1" === e.getFieldValue("DIRECTION") ? 1 : -1,
            i = e.getFieldValue("TYPE"),
            a = window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
              "listsGetSortCompare",
              [
                `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(type, direction) {
            var compareFuncs = {
                NUMERIC: function(a, b) {
                    return parseFloat(a) - parseFloat(b);
                },
                TEXT: function(a, b) {
                    return a.toString() > b.toString() ? 1 : -1;
                }
            };

            return function(a, b) {
                return compareFuncs[type](a, b) * direction; 
            }
        }`,
              ]
            );
          return [
            `${t}.sort().slice(0).sort(${a}("${i}", ${o}))`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        }),
        (window.Blockly.Blocks.lists_statement = {
          required_parent_type: "lists_create_with",
          init() {
            this.required_parent_id = "";
            let e = new window.Blockly.FieldImage(l.fK, 25, 25, "", () =>
              this.onIconClick()
            );
            this.jsonInit(this.definition()),
              this.appendDummyInput("REMOVE_ICON").appendField(e);
          },
          definition: () => ({
            message0: "%1",
            args0: [{ type: "input_value", name: "VALUE" }],
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.List,
          }),
          meta: () => ({
            display_name: (0, i.NC)("List Statement"),
            description: "",
          }),
          onIconClick() {
            !this.workspace.options.readOnly &&
              !window.Blockly.derivWorkspace.isFlyoutVisible &&
              (0, a.UR)(!1, () => {
                this.unplug(!0), this.dispose();
              });
          },
          onchange(e) {
            if (
              !(
                !this.workspace ||
                window.Blockly.derivWorkspace.isFlyoutVisible ||
                this.workspace.isDragging()
              ) &&
              e.type === window.Blockly.Events.BLOCK_DRAG &&
              !e.isStart
            ) {
              let e = this.getSurroundParent();
              if (e) {
                if (
                  this.required_parent_id ||
                  e.type !== this.required_parent_type
                ) {
                  if (e.id !== this.required_parent_id) {
                    let e = this.workspace
                      .getAllBlocks()
                      .find((e) => e.id === this.required_parent_id);
                    if (e) {
                      let t = e.getLastConnectionInStatement("STACK");
                      (0, a.$9)(() => {
                        t.connect(this.previousConnection);
                      });
                    } else
                      (0, a.$9)(() => {
                        this.dispose(!0);
                      });
                  }
                } else this.required_parent_id = e.id;
              } else
                (0, a.$9)(() => {
                  this.dispose();
                });
            }
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lists_statement =
          (e) => [
            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "VALUE",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
            ) || "null",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.controls_repeat_ext = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("repeat {{ number }} times", { number: "%1" }),
            args0: [{ type: "input_value", name: "TIMES", check: "Number" }],
            message1: (0, i.NC)("do %1"),
            args1: [{ type: "input_statement", name: "DO" }],
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Repeats inside instructions specified number of times"
            ),
            category: window.Blockly.Categories.Loop,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Repeat (2)"),
            description: (0, i.NC)(
              "This block is similar to the block above, except that the number of times it repeats is determined by a given variable."
            ),
          }),
          getRequiredValueInputs: () => ({ TIMES: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_repeat_ext =
          (e) => {
            let t;
            t = e.getField("TIMES")
              ? String(Number(e.getFieldValue("TIMES")))
              : window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TIMES",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "0";
            let o =
                window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                  e,
                  "DO"
                ),
              i = "",
              a = window.Blockly.JavaScript.variableDB_.getDistinctName(
                "count",
                window.Blockly.Variables.CATEGORY_NAME
              ),
              l = t;
            return (
              t.match(/^\w+$/) ||
                window.Blockly.isNumber(t) ||
                ((l = window.Blockly.JavaScript.variableDB_.getDistinctName(
                  "repeat_end",
                  window.Blockly.Variables.CATEGORY_NAME
                )),
                (i += `var ${l} = ${t};
`)),
              (i += `
    for (var ${a} = 0; ${a} < ${l}; ${a}++) {
        ${o}
    }
`)
            );
          }),
        (window.Blockly.Blocks.controls_repeat = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            type: "controls_repeat",
            message0: (0, i.NC)("repeat {{ number }} times", { number: "%1" }),
            args0: [
              {
                type: "field_number",
                name: "TIMES",
                value: 10,
                min: 0,
                precision: 1,
              },
            ],
            message1: (0, i.NC)("do %1"),
            args1: [{ type: "input_statement", name: "DO" }],
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Repeats inside instructions specified number of times"
            ),
            category: window.Blockly.Categories.Loop,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Repeat (1)"),
            description: (0, i.NC)(
              "This block repeats the instructions contained within for a specific number of times."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_repeat =
          window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_repeat_ext),
        (window.Blockly.Blocks.controls_whileUntil = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("repeat {{ while_or_until }} {{ boolean }}", {
              while_or_until: "%1",
              boolean: "%2",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "MODE",
                options: [
                  [(0, i.NC)("while"), "WHILE"],
                  [(0, i.NC)("until"), "UNTIL"],
                ],
              },
              { type: "input_value", name: "BOOL", check: "Boolean" },
            ],
            message1: (0, i.NC)("do %1"),
            args1: [{ type: "input_statement", name: "DO" }],
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "This block repeats instructions as long as a given condition is true"
            ),
            category: window.Blockly.Categories.Loop,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Repeat While/Until"),
            description: (0, i.NC)(
              "This block repeats instructions as long as a given condition is true."
            ),
          }),
          getRequiredValueInputs: () => ({ BOOL: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_whileUntil =
          (e) => {
            let t =
                window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                  e,
                  "DO"
                ),
              o = "UNTIL" === e.getFieldValue("MODE"),
              a = o
                ? window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_LOGICAL_NOT
                : window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE,
              l =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "BOOL",
                  a
                ) || "false";
            o && (l = `!${l}`);
            let n = window.Blockly.JavaScript.variableDB_.getDistinctName(
                "maxLoops",
                window.Blockly.Variables.CATEGORY_NAME
              ),
              r = window.Blockly.JavaScript.variableDB_.getDistinctName(
                "currentLoop",
                window.Blockly.Variables.CATEGORY_NAME
              );
            return `
        var ${n} = 10000;
        var ${r} = 0;

        while (${l}) {
            if (${r} > ${n}) {
                throw new Error("${(0, i.NC)("Infinite loop detected")}");
            } else {
                ${r}++;
            }
            
            ${t}
        }
`;
          }),
        (window.Blockly.Blocks.controls_for = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "count with {{ variable }} from {{ start_number }} to {{ end_number }} by {{ step_size }}",
              {
                variable: "%1",
                start_number: "%2",
                end_number: "%3",
                step_size: "%4",
              }
            ),
            args0: [
              { type: "field_variable", name: "VAR", variable: null },
              { type: "input_value", name: "FROM", check: "Number" },
              { type: "input_value", name: "TO", check: "Number" },
              { type: "input_value", name: "BY", check: "Number" },
            ],
            message1: (0, i.NC)("do %1"),
            args1: [{ type: "input_statement", name: "DO" }],
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "This block uses the variable “i” to control the iterations. With each iteration, the value of “i” is determined by the items in a given list."
            ),
            category: window.Blockly.Categories.Loop,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Iterate (1)"),
            description: (0, i.NC)(
              "This block uses the variable “i” to control the iterations. With each iteration, the value of “i” is determined by the items in a given list."
            ),
          }),
          getRequiredValueInputs: () => ({ FROM: null, TO: null, BY: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_for = (
          e
        ) => {
          let t = window.Blockly.JavaScript.variableDB_.getName(
              e.getFieldValue("VAR"),
              window.Blockly.Variables.CATEGORY_NAME
            ),
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "FROM",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ASSIGNMENT
              ) || "0",
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "TO",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ASSIGNMENT
              ) || "0",
            a =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "BY",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ASSIGNMENT
              ) || "1",
            l = window.Blockly.JavaScript.javascriptGenerator.statementToCode(
              e,
              "DO"
            );
          l = window.Blockly.JavaScript.javascriptGenerator.addLoopTrap(
            l,
            e.id
          );
          let n = "";
          if (
            window.Blockly.isNumber(o) &&
            window.Blockly.isNumber(i) &&
            window.Blockly.isNumber(a)
          ) {
            let e = parseFloat(o) <= parseFloat(i),
              r = Math.abs(parseFloat(a)),
              s = `${t} = ${o}`,
              c = `${t} ${e ? "<=" : ">="} ${i}`,
              u = `${t} ${e ? "+=" : "-="} ${r}`;
            n = `
        for (${s}; ${c}; ${u}) {
            ${l}
        }
`;
          } else {
            let e = o;
            o.match(/^\w+$/) ||
              window.Blockly.isNumber(o) ||
              ((e = window.Blockly.JavaScript.variableDB_.getDistinctName(
                `${t}_start`,
                window.Blockly.Variables.CATEGORY_NAME
              )),
              (n = `var ${e} = ${o};
`));
            let r = i;
            i.match(/^\w+$/) ||
              window.Blockly.isNumber(i) ||
              ((r = window.Blockly.JavaScript.variableDB_.getDistinctName(
                `${t}_end`,
                window.Blockly.Variables.CATEGORY_NAME
              )),
              (n += `var ${r} = ${i};
`));
            let s = window.Blockly.JavaScript.variableDB_.getDistinctName(
                `${t}_inc`,
                window.Blockly.Variables.CATEGORY_NAME
              ),
              c = window.Blockly.isNumber(a) ? Math.abs(a) : `Math.abs(${a})`;
            n += `
        var ${s} = ${c};
        if (${e} > ${r}) {
            ${s} = -${s};
        }
        for (
           ${t} = ${e}; 
           ${s} >= 0 ? ${t} <= ${r} : ${t} >= ${r};
           ${t} += ${s}
        ) {
            ${l};
        }
`;
          }
          return n;
        }),
        (window.Blockly.Blocks.controls_forEach = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "for each item {{ variable }} in list {{ input_list }}",
              { variable: "%1", input_list: "%2" }
            ),
            args0: [
              { type: "field_variable", name: "VAR", variable: null },
              { type: "input_value", name: "LIST", check: "Array" },
            ],
            message1: (0, i.NC)("do %1"),
            args1: [{ type: "input_statement", name: "DO" }],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Iterates through a given list"),
            category: window.Blockly.Categories.Loop,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Iterate (2)"),
            description: (0, i.NC)(
              'This block uses the variable "i" to control the iterations. With each iteration, the value of "i" is determined by the items in a given list.'
            ),
          }),
          getRequiredValueInputs: () => ({ LIST: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_forEach =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VAR"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "LIST",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ASSIGNMENT
                ) || "[]",
              i = window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "DO"
              );
            i = window.Blockly.JavaScript.javascriptGenerator.addLoopTrap(
              i,
              e.id
            );
            let a = "",
              l = o;
            o.match(/^\w+$/) ||
              ((l = window.Blockly.JavaScript.variableDB_.getDistinctName(
                `${t}_list`,
                window.Blockly.Variables.CATEGORY_NAME
              )),
              (a = `var ${l} = ${o};
`));
            let n = window.Blockly.JavaScript.variableDB_.getDistinctName(
              `${t}_list`,
              window.Blockly.Variables.CATEGORY_NAME
            );
            return (
              a +
              `
    for (var ${n} in ${l}) {
        ${t} = ${l}[${n}];
        ${i}
    }
`
            );
          }),
        (window.Blockly.Blocks.controls_flow_statements = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("{{ break_or_continue }} of loop", {
              break_or_continue: "%1",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "FLOW",
                options: [
                  [(0, i.NC)("break out"), "BREAK"],
                  [(0, i.NC)("continue with next iteration"), "CONTINUE"],
                ],
              },
            ],
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "This block is used to either terminate or continue a loop, and can be placed anywhere within a loop block."
            ),
            category: window.Blockly.Categories.Loop,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Break out/continue"),
            description: (0, i.NC)(
              "This block is used to either terminate or continue a loop, and can be placed anywhere within a loop block."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_flow_statements =
          (e) => {
            let t = "BREAK" === e.getFieldValue("FLOW") ? "break" : "continue";
            return `${t};
`;
          }),
        (window.Blockly.Blocks.variables_get = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            type: "variables_get",
            message0: "%1",
            args0: [
              {
                type: "field_variable",
                name: "VAR",
                variable: (0, i.NC)("item"),
              },
            ],
            output: null,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Special4.colour,
            colourSecondary: window.Blockly.Colours.Special4.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special4.colourTertiary,
            tooltip: (0, i.NC)("Gets variable value"),
            category: window.Blockly.Categories.Variables,
          }),
          meta: () => ({
            display_name: (0, i.NC)("User-defined variable"),
            description: "",
          }),
          onchange(e) {
            if (e.type === window.Blockly.Events.VAR_RENAME) {
              let t = this.workspace
                  .getAllBlocks()
                  .filter((e) => "custom_functions" === e.category_),
                o = e.oldName,
                a = e.newName;
              t.forEach((e) => {
                var t;
                if (
                  null === (t = e.arguments) || void 0 === t ? void 0 : t.length
                ) {
                  let t = e.arguments.findIndex((e) => e === o);
                  -1 !== t &&
                    ((e.arguments[t] = a),
                    e.getField("PARAMS") &&
                      e.setFieldValue(
                        `${(0, i.NC)("with: ")} ${e.arguments.join(", ")}`,
                        "PARAMS"
                      ),
                    e.getField("WITH") && e.updateShape());
                }
              });
            }
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.variables_get =
          (e) => [
            window.Blockly.JavaScript.variableDB_.getName(
              e.getFieldValue("VAR"),
              window.Blockly.Variables.CATEGORY_NAME
            ),
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.variables_set = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            type: "field_variable",
            message0: (0, i.NC)("set {{ variable }} to {{ value }}", {
              variable: "%1",
              value: "%2",
            }),
            args0: [
              {
                type: "field_variable",
                name: "VAR",
                variable: (0, i.NC)("item"),
              },
              { type: "input_value", name: "VALUE" },
            ],
            colour: window.Blockly.Colours.Special2.colour,
            colourSecondary: window.Blockly.Colours.Special2.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special2.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Sets variable value"),
            category: window.Blockly.Categories.Variables,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Set variable"),
            description: (0, i.NC)("Assigns a given value to a variable"),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.variables_set =
          (e) => {
            let t =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "VALUE",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ASSIGNMENT
                ) || "0",
              o = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VAR"),
                window.Blockly.Variables.CATEGORY_NAME
              );
            return `${o} = ${t};
`;
          }),
        (window.Blockly.Blocks.after_purchase = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            message1: "%1",
            message2: "%1",
            args0: [
              {
                type: "field_image",
                src: l.DV,
                width: 25,
                height: 25,
                alt: "F",
              },
              {
                type: "field_label",
                text: (0, i.NC)("4. Restart trading conditions"),
                class: "blocklyTextRootBlockHeader",
              },
              { type: "input_dummy" },
            ],
            args1: [
              {
                type: "input_statement",
                name: "AFTERPURCHASE_STACK",
                check: "TradeAgain",
              },
            ],
            args2: [{ type: "field_image", src: " ", width: 380, height: 10 }],
            colour: window.Blockly.Colours.RootBlock.colour,
            colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
            colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
            tooltip: (0, i.NC)(
              "Get the last trade information and result, then trade again."
            ),
            category: window.Blockly.Categories.After_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Restart trading conditions"),
            description: (0, i.NC)(
              "Here is where you can decide if your bot should continue trading."
            ),
          }),
          onchange(e) {
            (e.type === window.Blockly.Events.BLOCK_CHANGE ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart)) &&
              this.isCollapsed() &&
              (0, a.AA)(this);
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.after_purchase =
          (e) => {
            let t =
              window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "AFTERPURCHASE_STACK"
              );
            return `
    BinaryBotPrivateAfterPurchase = function BinaryBotPrivateAfterPurchase() {
        Bot.highlightBlock('${e.id}');
        ${t}
        Bot.isTradeAgain(false);
        return false;
    };`;
          });
      var n = o(47962);
      (window.Blockly.Blocks.contract_check_result = {
        init() {
          this.jsonInit(this.definition());
        },
        definition: () => ({
          message0: (0, i.NC)("Result is {{ win_or_loss }}", {
            win_or_loss: "%1",
          }),
          args0: [
            {
              type: "field_dropdown",
              name: "CHECK_RESULT",
              options: (0, n.v)().lists.CHECK_RESULT,
            },
          ],
          output: "Boolean",
          outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
          colour: window.Blockly.Colours.Base.colour,
          colourSecondary: window.Blockly.Colours.Base.colourSecondary,
          colourTertiary: window.Blockly.Colours.Base.colourTertiary,
          tooltip: (0, i.NC)(
            "True if the result of the last trade matches the selection"
          ),
          category: window.Blockly.Categories.After_Purchase,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Last trade result"),
          description: (0, i.NC)(
            "You can check the result of the last trade with this block."
          ),
        }),
        onchange(e) {
          if (
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) &&
            (e.type === window.Blockly.Events.BLOCK_CREATE ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart))
          ) {
            let e = this.getTopParent();
            e &&
              e.isMainBlock() &&
              "after_purchase" !== e.type &&
              this.setDisabled(!0);
          }
        },
        customContextMenu(e) {
          (0, a.Z3)(e);
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.contract_check_result =
          (e) => {
            let t = e.getFieldValue("CHECK_RESULT");
            return [
              `Bot.isResult('${t}')`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
            ];
          }),
        (window.Blockly.Blocks.read_details = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Contract Details: {{ contract_detail }}", {
              contract_detail: "%1",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "DETAIL_INDEX",
                options: (0, n.v)().lists.DETAILS,
              },
            ],
            output: null,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Reads a selected property from contract details list"
            ),
            category: window.Blockly.Categories.After_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Contract details"),
            description: (0, i.NC)(
              "This block gives you information about your last contract."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          restricted_parents: ["after_purchase"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.read_details = (
          e
        ) => {
          let t = e.getFieldValue("DETAIL_INDEX");
          return [
            `Bot.readDetails(${t})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.trade_again = {
          init() {
            this.jsonInit(this.definition()), this.setNextStatement(!1);
          },
          definition: () => ({
            message0: (0, i.NC)("Trade again"),
            colour: window.Blockly.Colours.Special1.colour,
            colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
            previousStatement: null,
            tooltip: (0, i.NC)(
              "These blocks transfer control to the Purchase conditions block."
            ),
            category: window.Blockly.Categories.After_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Trade again"),
            description: (0, i.NC)(
              "This block will transfer the control back to the Purchase conditions block, enabling you to purchase another contract."
            ),
            key_words: (0, i.NC)("restart"),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          restricted_parents: ["after_purchase"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_again =
          () => `
        Bot.isTradeAgain(true);

        return true;

    `),
        (window.Blockly.Blocks.before_purchase = {
          init() {
            this.jsonInit(this.definition()), this.setDeletable(!1);
          },
          definition: () => ({
            message0: "%1 %2 %3",
            message1: "%1",
            message2: "%1",
            args0: [
              {
                type: "field_image",
                src: l.e_,
                width: 25,
                height: 25,
                alt: "P",
              },
              {
                type: "field_label",
                text: (0, i.NC)("2. Purchase conditions"),
                class: "blocklyTextRootBlockHeader",
              },
              { type: "input_dummy" },
            ],
            args1: [
              {
                type: "input_statement",
                name: "BEFOREPURCHASE_STACK",
                check: "Purchase",
              },
            ],
            args2: [{ type: "field_image", src: " ", width: 380, height: 10 }],
            colour: window.Blockly.Colours.RootBlock.colour,
            colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
            colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
            tooltip: (0, i.NC)(
              "Specify contract type and purchase conditions."
            ),
            category: window.Blockly.Categories.Before_Purchase,
          }),
          onchange(e) {
            (e.type === window.Blockly.Events.BLOCK_CHANGE ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart)) &&
              this.isCollapsed() &&
              (0, a.AA)(this);
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Purchase conditions"),
            description: (0, i.NC)(
              "This block is mandatory. Only one copy of this block is allowed. You can place the Purchase block (see below) here as well as conditional blocks to define your purchase conditions."
            ),
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.before_purchase =
          (e) => {
            let t =
              window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "BEFOREPURCHASE_STACK"
              );
            return `BinaryBotPrivateBeforePurchase = function BinaryBotPrivateBeforePurchase() {
        Bot.highlightBlock('${e.id}');
        ${t}
    };
`;
          });
      var r = o(1560);
      (window.Blockly.Blocks.purchase = {
        init() {
          this.jsonInit(this.definition()), this.setNextStatement(!1);
        },
        definition: () => ({
          message0: (0, i.NC)("Purchase {{ contract_type }}", {
            contract_type: "%1",
          }),
          args0: [
            {
              type: "field_dropdown",
              name: "PURCHASE_LIST",
              options: [["", ""]],
            },
          ],
          previousStatement: null,
          colour: window.Blockly.Colours.Special1.colour,
          colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
          colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
          tooltip: (0, i.NC)(
            "This block purchases contract of a specified type."
          ),
          category: window.Blockly.Categories.Before_Purchase,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Purchase"),
          description: (0, i.NC)(
            "Use this block to purchase the specific contract you want. You may add multiple Purchase blocks together with conditional blocks to define your purchase conditions. This block can only be used within the Purchase conditions block."
          ),
          key_words: (0, i.NC)("buy"),
        }),
        onchange(e) {
          !(
            !this.workspace ||
            window.Blockly.derivWorkspace.isFlyoutVisible ||
            this.workspace.isDragging()
          ) &&
            (e.type === window.Blockly.Events.BLOCK_CREATE &&
            e.ids.includes(this.id)
              ? this.populatePurchaseList(e)
              : e.type === window.Blockly.Events.BLOCK_CHANGE
              ? ("TYPE_LIST" === e.name || "TRADETYPE_LIST" === e.name) &&
                this.populatePurchaseList(e)
              : e.type !== window.Blockly.Events.BLOCK_DRAG ||
                e.isStart ||
                e.blockId !== this.id ||
                "" !== this.getField("PURCHASE_LIST").menuGenerator_[0][0] ||
                this.populatePurchaseList(e));
        },
        populatePurchaseList(e) {
          let t = this.workspace.getTradeDefinitionBlock();
          if (t) {
            let o = t
                .getChildByType("trade_definition_tradetype")
                .getFieldValue("TRADETYPE_LIST"),
              i = t
                .getChildByType("trade_definition_contracttype")
                .getFieldValue("TYPE_LIST"),
              a = this.getField("PURCHASE_LIST"),
              l = a.getValue(),
              n = (0, r.M)(i, o);
            a.updateOptions(n, {
              default_value: l,
              event_group: e.group,
              should_pretend_empty: !0,
            });
          }
        },
        customContextMenu(e) {
          let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
          (0, a.ei)(e, t), (0, a.Z3)(e);
        },
        restricted_parents: ["before_purchase"],
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.purchase = (
          e
        ) => {
          let t = e.getFieldValue("PURCHASE_LIST");
          return `Bot.purchase('${t}');
`;
        }),
        (window.Blockly.Blocks.ask_price = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Ask Price {{ contract_type }}", {
              contract_type: "%1",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "PURCHASE_LIST",
                options: [["", ""]],
              },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block returns the purchase price for the selected trade type."
            ),
            category: window.Blockly.Categories.Before_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Purchase price"),
            description: (0, i.NC)(
              'This block returns the purchase price for the selected trade type. This block can be used only in the "Purchase conditions" root block.'
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.purchase.onchange,
          populatePurchaseList:
            window.Blockly.Blocks.purchase.populatePurchaseList,
          enforceLimitations: window.Blockly.Blocks.purchase.enforceLimitations,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ask_price = (
          e
        ) => {
          let t = e.getFieldValue("PURCHASE_LIST");
          return [
            `Bot.getAskPrice('${t}')`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.payout = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Payout {{ contract_type }}", {
              contract_type: "%1",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "PURCHASE_LIST",
                options: [["", ""]],
              },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block returns the potential payout for the selected trade type"
            ),
            category: window.Blockly.Categories.Before_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Potential payout"),
            description: (0, i.NC)(
              'This block returns the potential payout for the selected trade type. This block can be used only in the "Purchase conditions" root block.'
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.purchase.onchange,
          populatePurchaseList:
            window.Blockly.Blocks.purchase.populatePurchaseList,
          enforceLimitations: window.Blockly.Blocks.purchase.enforceLimitations,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.payout = (
          e
        ) => {
          let t = e.getFieldValue("PURCHASE_LIST");
          return [
            `Bot.getPayout('${t}')`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.during_purchase = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            message1: "%1",
            message2: "%1",
            args0: [
              {
                type: "field_image",
                src: l.dp,
                width: 25,
                height: 25,
                alt: "S",
              },
              {
                type: "field_label",
                text: (0, i.NC)("3. Sell conditions"),
                class: "blocklyTextRootBlockHeader",
              },
              { type: "input_dummy" },
            ],
            args1: [
              {
                type: "input_statement",
                name: "DURING_PURCHASE_STACK",
                check: "SellAtMarket",
              },
            ],
            args2: [{ type: "field_image", src: " ", width: 380, height: 10 }],
            colour: window.Blockly.Colours.RootBlock.colour,
            colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
            colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
            tooltip: (0, i.NC)(
              "Sell your active contract if needed (optional)"
            ),
            category: window.Blockly.Categories.During_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Sell conditions"),
            description: (0, i.NC)(
              "Here is where you can decide to sell your contract before it expires. Only one copy of this block is allowed."
            ),
          }),
          onchange(e) {
            (e.type === window.Blockly.Events.BLOCK_CHANGE ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart)) &&
              this.isCollapsed() &&
              (0, a.AA)(this);
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.during_purchase =
          (e) => {
            let t =
              window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "DURING_PURCHASE_STACK"
              );
            return `BinaryBotPrivateDuringPurchase = function BinaryBotPrivateDuringPurchase() {
        Bot.highlightBlock('${e.id}');
        ${t}
    };
`;
          }),
        (window.Blockly.Blocks.sell_at_market = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Sell at market price"),
            colour: window.Blockly.Colours.Special1.colour,
            colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Use this block to sell your contract at the market price."
            ),
            category: window.Blockly.Categories.During_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Sell at market price"),
            description: (0, i.NC)(
              "Use this block to sell your contract at the market price."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          restricted_parents: ["during_purchase"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.sell_at_market =
          () => "Bot.sellAtMarket();\n"),
        (window.Blockly.Blocks.check_sell = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Sell is available"),
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "True if active contract can be sold before expiration at current market price"
            ),
            category: window.Blockly.Categories.During_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Can contract be sold?"),
            description: (0, i.NC)(
              "This block helps you check if your contract can be sold. If your contract can be sold, it returns “True”. Otherwise, it returns an empty string."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          restricted_parents: ["during_purchase"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.check_sell =
          () => [
            "Bot.isSellAvailable()",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.sell_price = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Sell profit/loss"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns the profit/loss from selling at market price"
            ),
            category: window.Blockly.Categories.During_Purchase,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Profit/loss from selling"),
            description: (0, i.NC)(
              "This block gives you the potential profit or loss if you decide to sell your contract."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          restricted_parents: ["during_purchase"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.sell_price =
          () => [
            "Bot.getSellPrice()",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.bb_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: [
            "input_list",
            "period",
            "std_dev_multiplier_up",
            "std_dev_multiplier_down",
          ],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Bollinger Bands {{ band_type }} {{ dummy }}",
              { variable: "%1", band_type: "%2", dummy: "%3" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "bb" },
              {
                type: "field_dropdown",
                name: "BBRESULT_LIST",
                options: (0, n.v)().bbResult,
              },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Bollinger Bands (BB) from a list with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Bollinger Bands (BB)"),
            description: (0, i.NC)(
              "BB is a technical analysis indicator that’s commonly used by traders. The idea behind BB is that the market price stays within the upper and lower bands for 95% of the time. The bands are the standard deviations of the market price, while the line in the middle is a simple moving average line. If the price reaches either the upper or lower band, there’s a possibility of a trend reversal."
            ),
          }),
          onchange(e) {
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) &&
              (e.type !== window.Blockly.Events.BLOCK_DRAG ||
                e.isStart ||
                this.getBlocksInStatement("STATEMENT").forEach((e) => {
                  this.required_child_blocks.includes(e.type) ||
                    (window.Blockly.Events.disable(),
                    e.unplug(!1),
                    window.Blockly.Events.enable());
                }));
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.bb_statement = (
          e
        ) => {
          let t = window.Blockly.JavaScript.variableDB_.getName(
              e.getFieldValue("VARIABLE"),
              window.Blockly.Variables.CATEGORY_NAME
            ),
            o = e.getFieldValue("BBRESULT_LIST"),
            i = e.childValueToCode("input_list", "INPUT_LIST"),
            a = e.childValueToCode("period", "PERIOD"),
            l = e.childValueToCode("std_dev_multiplier_up", "UPMULTIPLIER"),
            n = e.childValueToCode("std_dev_multiplier_down", "DOWNMULTIPLIER");
          return `${t} = Bot.bb(${i}, { 
        periods: ${a}, 
        stdDevUp: ${l}, 
        stdDevDown: ${n} 
    }, ${o});
`;
        }),
        (window.Blockly.Blocks.bba_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: [
            "input_list",
            "period",
            "std_dev_multiplier_up",
            "std_dev_multiplier_down",
          ],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Bollinger Bands Array {{ band_type }} {{ dummy }}",
              { variable: "%1", band_type: "%2", dummy: "%3" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "bba" },
              {
                type: "field_dropdown",
                name: "BBRESULT_LIST",
                options: (0, n.v)().bbResult,
              },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Bollinger Bands (BB) list from a list with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Bollinger Bands Array (BBA)"),
            description: (0, i.NC)(
              "Similar to BB. This block gives you a choice of returning the values of either the lower band, higher band, or the SMA line in the middle."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.bba_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.getFieldValue("BBRESULT_LIST"),
              i = e.childValueToCode("input_list", "INPUT_LIST"),
              a = e.childValueToCode("period", "PERIOD"),
              l = e.childValueToCode("std_dev_multiplier_up", "UPMULTIPLIER"),
              n = e.childValueToCode(
                "std_dev_multiplier_down",
                "DOWNMULTIPLIER"
              );
            return `${t} = Bot.bba(${i}, { 
        periods: ${a}, 
        stdDevUp: ${l}, 
        stdDevDown: ${n} 
    }, ${o});
`;
          }),
        (window.Blockly.Blocks.ema_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: ["input_list", "period"],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Exponential Moving Average {{ dummy }}",
              { variable: "%1", dummy: "%2" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "ema" },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Exponential Moving Average (EMA) from a list with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Exponential Moving Average (EMA)"),
            description: (0, i.NC)(
              "EMA is a type of moving average that places more significance on the most recent data points. It’s also known as the exponentially weighted moving average. EMA is different from SMA in that it reacts more significantly to recent price changes."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ema_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.childValueToCode("input_list", "INPUT_LIST"),
              i = e.childValueToCode("period", "PERIOD");
            return `${t} = Bot.ema(${o}, ${i});
`;
          }),
        (window.Blockly.Blocks.emaa_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: ["input_list", "period"],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Exponential Moving Average Array {{ dummy }}",
              { variable: "%1", dummy: "%2" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "emaa" },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Exponential Moving Average (EMA) list from a list of values with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Exponential Moving Average Array (EMAA)"),
            description: (0, i.NC)(
              "This block is similar to EMA, except that it gives you the entire EMA line based on the input list and the given period."
            ),
          }),
          onchange: window.Blockly.Blocks.bb_statement.onchange,
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.emaa_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.childValueToCode("input_list", "INPUT_LIST"),
              i = e.childValueToCode("period", "PERIOD");
            return `${t} = Bot.emaa(${o}, ${i});
`;
          }),
        (window.Blockly.Blocks.rsi_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: ["input_list", "period"],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Relative Strength Index {{ dummy }}",
              { variable: "%1", dummy: "%2" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "rsi" },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Relative Strength Index (RSI) from a list with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Relative Strength Index (RSI)"),
            description: (0, i.NC)(
              "RSI is a technical analysis tool that helps you identify the market trend. It will give you a value from 0 to 100. An RSI value of 70 and above means that the asset is overbought and the current trend may reverse, while a value of 30 and below means that the asset is oversold."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.rsi_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.childValueToCode("input_list", "INPUT_LIST"),
              i = e.childValueToCode("period", "PERIOD");
            return `${t} = Bot.rsi(${o}, ${i});
`;
          }),
        (window.Blockly.Blocks.rsia_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: ["input_list", "period"],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Relative Strength Index Array {{ dummy }}",
              { variable: "%1", dummy: "%2" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "rsia" },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Relative Strength Index (RSI) list from a list of values with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Relative Strength Index Array (RSIA)"),
            description: (0, i.NC)(
              "Similar to RSI, this block gives you a list of values for each entry in the input list."
            ),
          }),
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.rsia_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.childValueToCode("input_list", "INPUT_LIST"),
              i = e.childValueToCode("period", "PERIOD");
            return `${t} = Bot.rsia(${o}, ${i});
`;
          }),
        (window.Blockly.Blocks.sma_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: ["input_list", "period"],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Simple Moving Average {{ dummy }}",
              { variable: "%1", dummy: "%2" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "sma" },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Simple Moving Average (SMA) from a list with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Simple Moving Average (SMA)"),
            description: (0, i.NC)(
              "SMA is a frequently used indicator in technical analysis. It calculates the average market price over a specified period, and is usually used to identify market trend direction: up or down. For example, if the SMA is moving upwards, it means the market trend is up. "
            ),
          }),
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.sma_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.childValueToCode("input_list", "INPUT_LIST"),
              i = e.childValueToCode("period", "PERIOD");
            return `${t} = Bot.sma(${o}, ${i});
`;
          }),
        (window.Blockly.Blocks.smaa_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: ["input_list", "period"],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to Simple Moving Average Array {{ dummy }}",
              { variable: "%1", dummy: "%2" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "smaa" },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Simple Moving Average line from a list with a period"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Simple Moving Average Array (SMAA)"),
            description: (0, i.NC)(
              "Similar to SMA, this block gives you the entire SMA line containing a list of all values for a given period."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.smaa_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.childValueToCode("input_list", "INPUT_LIST"),
              i = e.childValueToCode("period", "PERIOD");
            return `${t} = Bot.smaa(${o}, ${i});
`;
          }),
        (window.Blockly.Blocks.macda_statement = {
          protected_statements: ["STATEMENT"],
          required_child_blocks: [
            "input_list",
            "fast_ema_period",
            "slow_ema_period",
            "signal_ema_period",
          ],
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "set {{ variable }} to MACD Array {{ dropdown }} {{ dummy }}",
              { variable: "%1", dropdown: "%2", dummy: "%3" }
            ),
            message1: "%1",
            args0: [
              { type: "field_variable", name: "VARIABLE", variable: "macda" },
              {
                type: "field_dropdown",
                name: "MACDFIELDS_LIST",
                options: (0, n.v)().macdFields,
              },
              { type: "input_dummy" },
            ],
            args1: [
              { type: "input_statement", name: "STATEMENT", check: null },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Calculates Moving Average Convergence Divergence (MACD) from a list"
            ),
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Indicators,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Moving Average Convergence Divergence"),
            description: (0, i.NC)(
              "MACD is calculated by subtracting the long-term EMA (26 periods) from the short-term EMA (12 periods). If the short-term EMA is greater or lower than the long-term EMA than there’s a possibility of a trend reversal."
            ),
          }),
          onchange: window.Blockly.Blocks.bb_statement.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.macda_statement =
          (e) => {
            let t = window.Blockly.JavaScript.variableDB_.getName(
                e.getFieldValue("VARIABLE"),
                window.Blockly.Variables.CATEGORY_NAME
              ),
              o = e.getFieldValue("MACDFIELDS_LIST"),
              i = e.childValueToCode("input_list", "INPUT_LIST"),
              a = e.childValueToCode("fast_ema_period", "FAST_EMA_PERIOD"),
              l = e.childValueToCode("slow_ema_period", "SLOW_EMA_PERIOD"),
              n = e.childValueToCode("signal_ema_period", "SIGNAL_EMA_PERIOD");
            return `${t} = Bot.macda(${i}, { 
        fastEmaPeriod: ${a},
        slowEmaPeriod: ${l},
        signalEmaPeriod: ${n},
    }, ${o});
`;
          }),
        (window.Blockly.Blocks.input_list = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)("Input List {{ input_list }}", {
                input_list: "%1",
              }),
              args0: [
                { type: "input_value", name: "INPUT_LIST", check: "Array" },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange(e) {
            if (
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            )
              return;
            let t = () => {
              let e = this.getSurroundParent();
              e &&
                !this.required_parent_id &&
                this.allowed_parents.includes(e.type) &&
                (this.required_parent_id = e.id);
            };
            if (
              e.type === window.Blockly.Events.BLOCK_CREATE &&
              e.ids.includes(this.id)
            )
              t();
            else if (
              e.type === window.Blockly.Events.BLOCK_DRAG &&
              !e.isStart
            ) {
              t();
              let e = this.getSurroundParent(),
                o = !!e,
                i = !o || e.id !== this.required_parent_id;
              (!o || i) &&
                (0, a.$9)(() => {
                  this.unplug(!0);
                  let e = this.workspace
                    .getAllBlocks()
                    .find((e) => e.id === this.required_parent_id);
                  e
                    ? e
                        .getLastConnectionInStatement("STATEMENT")
                        .connect(this.previousConnection)
                    : this.dispose();
                });
            }
          },
          allowed_parents: [
            "bb_statement",
            "bba_statement",
            "ema_statement",
            "emaa_statement",
            "macda_statement",
            "rsi_statement",
            "rsia_statement",
            "sma_statement",
            "smaa_statement",
          ],
          getRequiredValueInputs: () => ({ INPUT_LIST: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.input_list =
          () => {}),
        (window.Blockly.Blocks.period = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)("Period {{ input_period }}", {
                input_period: "%1",
              }),
              args0: [{ type: "input_value", name: "PERIOD", check: null }],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange: window.Blockly.Blocks.input_list.onchange,
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          allowed_parents: [
            "bb_statement",
            "bba_statement",
            "ema_statement",
            "emaa_statement",
            "macda_statement",
            "rsi_statement",
            "rsia_statement",
            "sma_statement",
            "smaa_statement",
          ],
          getRequiredValueInputs: () => ({ PERIOD: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.period =
          () => {}),
        (window.Blockly.Blocks.std_dev_multiplier_up = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)(
                "Standard Deviation Up Multiplier {{ input_number }}",
                { input_number: "%1" }
              ),
              args0: [
                { type: "input_value", name: "UPMULTIPLIER", check: null },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange: window.Blockly.Blocks.input_list.onchange,
          allowed_parents: ["bb_statement", "bba_statement"],
          getRequiredValueInputs: () => ({ UPMULTIPLIER: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.std_dev_multiplier_up =
          () => {}),
        (window.Blockly.Blocks.std_dev_multiplier_down = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)(
                "Standard Deviation Down Multiplier {{ input_number }}",
                { input_number: "%1" }
              ),
              args0: [
                { type: "input_value", name: "DOWNMULTIPLIER", check: null },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange: window.Blockly.Blocks.input_list.onchange,
          allowed_parents: ["bb_statement", "bba_statement"],
          getRequiredValueInputs: () => ({ DOWNMULTIPLIER: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.std_dev_multiplier_down =
          () => {}),
        (window.Blockly.Blocks.fast_ema_period = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)("Fast EMA Period {{ input_number }}", {
                input_number: "%1",
              }),
              args0: [
                { type: "input_value", name: "FAST_EMA_PERIOD", check: null },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.input_list.onchange,
          allowed_parents: ["macda_statement"],
          getRequiredValueInputs: () => ({ FAST_EMA_PERIOD: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.fast_ema_period =
          () => {}),
        (window.Blockly.Blocks.slow_ema_period = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)("Slow EMA Period {{ input_number }}", {
                input_number: "%1",
              }),
              args0: [
                { type: "input_value", name: "SLOW_EMA_PERIOD", check: null },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange: window.Blockly.Blocks.input_list.onchange,
          allowed_parents: ["macda_statement"],
          getRequiredValueInputs: () => ({ SLOW_EMA_PERIOD: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.slow_ema_period =
          () => {}),
        (window.Blockly.Blocks.signal_ema_period = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)("Signal EMA Period {{ input_number }}", {
                input_number: "%1",
              }),
              args0: [
                { type: "input_value", name: "SIGNAL_EMA_PERIOD", check: null },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange: window.Blockly.Blocks.input_list.onchange,
          allowed_parents: ["macda_statement"],
          getRequiredValueInputs: () => ({ SIGNAL_EMA_PERIOD: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.signal_ema_period =
          () => {}),
        (window.Blockly.Blocks.tick = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Last Tick"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the value of the last tick"),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Last tick"),
            description: (0, i.NC)(
              "This block gives you the value of the last tick."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.Blocks.tick_string = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Last Tick String"),
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns the value of the latest tick in string format"
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Tick value"),
            description: (0, i.NC)("Tick value Description"),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.tick.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.tick = (e) => {
          let t = e.getParent();
          return [
            `Bot.getLastTick(false, ${["notify", "text_print"].includes(
              null == t ? void 0 : t.type
            )})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.tick_string =
          () => [
            "Bot.getLastTick(false, true)",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.ticks = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Ticks list"),
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you a list of the last 1000 tick values."
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Tick list"),
            description: (0, i.NC)(
              "This block gives you a list of the last 1000 tick values."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.Blocks.ticks_string = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Ticks String List"),
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns the list of tick values in string format"
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Tick List String"),
            description: (0, i.NC)("Tick List String Description"),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          onchange: window.Blockly.Blocks.ticks.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ticks = (e) => {
          let t = e.getParent();
          return [
            `Bot.getTicks(${["notify", "text_print"].includes(
              null == t ? void 0 : t.type
            )})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ticks_string =
          () => [
            "Bot.getTicks(true)",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.ohlc = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Candles List with interval here 2: {{ candle_interval_type }}",
              { candle_interval_type: "%1" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "CANDLEINTERVAL_LIST",
                options: (0, n.v)().candleIntervals,
              },
            ],
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you a list of candles within a selected time interval."
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Get candle list"),
            description: (0, i.NC)(
              "This block gives you a list of candles within a selected time interval."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ohlc = (e) => {
          let t = e.getFieldValue("CANDLEINTERVAL_LIST");
          return [
            `Bot.getOhlc({ granularity: ${
              "default" === t ? "undefined" : t
            } })`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.ohlc_values = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Make a List of {{ candle_property }} values in candles list with interval: {{ candle_interval_type }}",
              { candle_property: "%1", candle_interval_type: "%2" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "OHLCFIELD_LIST",
                options: (0, n.v)().ohlcFields,
              },
              {
                type: "field_dropdown",
                name: "CANDLEINTERVAL_LIST",
                options: (0, n.v)().candleIntervals,
              },
            ],
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns a list of specific values from a candle list according to selected time interval"
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Create a list of candle values (1)"),
            description: (0, i.NC)(
              "This block gives you the selected candle value from a list of candles within the selected time interval."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ohlc_values = (
          e
        ) => {
          let t = e.getFieldValue("CANDLEINTERVAL_LIST"),
            o = e.getFieldValue("OHLCFIELD_LIST");
          return [
            `Bot.getOhlc({ field: '${o}', granularity: ${
              "default" === t ? "undefined" : t
            } })`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.read_ohlc = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "In candles list read {{ candle_property }} # from end {{ input_number }}",
              { candle_property: "%1", input_number: "%2" }
            ),
            message1: (0, i.NC)("with interval: %1"),
            args0: [
              {
                type: "field_dropdown",
                name: "OHLCFIELD_LIST",
                options: (0, n.v)().ohlcFields,
              },
              { type: "input_value", name: "CANDLEINDEX", check: "Number" },
            ],
            args1: [
              {
                type: "field_dropdown",
                name: "CANDLEINTERVAL_LIST",
                options: (0, n.v)().candleIntervals,
              },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Read the selected candle value"),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Read candle value (1)"),
            description: (0, i.NC)(
              "This block gives you the specified candle value for a selected time interval."
            ),
          }),
          getRequiredValueInputs: () => ({ CANDLEINDEX: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.read_ohlc = (
          e
        ) => {
          let t = e.getFieldValue("CANDLEINTERVAL_LIST"),
            o = e.getFieldValue("OHLCFIELD_LIST"),
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "CANDLEINDEX",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || "1";
          return [
            `Bot.getOhlcFromEnd({ field: '${o}', index: ${i}, granularity: ${
              "default" === t ? "undefined" : t
            } })`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.get_ohlc = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "in candle list get # from end {{ input_number }}",
              { input_number: "%1" }
            ),
            message1: (0, i.NC)("with interval: {{ candle_interval_type }}", {
              candle_interval_type: "%1",
            }),
            args0: [
              { type: "input_value", name: "CANDLEINDEX", check: "Number" },
            ],
            args1: [
              {
                type: "field_dropdown",
                name: "CANDLEINTERVAL_LIST",
                options: (0, n.v)().candleIntervals,
              },
            ],
            output: "Candle",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you a specific candle from within the selected time interval."
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Get candle"),
            description: (0, i.NC)(
              "This block gives you a specific candle from within the selected time interval."
            ),
          }),
          getRequiredValueInputs: () => ({ CANDLEINDEX: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.get_ohlc = (
          e
        ) => {
          let t = e.getFieldValue("CANDLEINTERVAL_LIST"),
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "CANDLEINDEX",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || "1";
          return [
            `Bot.getOhlcFromEnd({ index: ${o}, granularity: ${
              "default" === t ? "undefined" : t
            } })`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.check_direction = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Direction is {{ direction_type }}", {
              direction_type: "%1",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "CHECK_DIRECTION",
                options: (0, n.v)().lists.CHECK_DIRECTION,
              },
            ],
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "True if the market direction matches the selection"
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Market direction"),
            description: (0, i.NC)(
              "This block is used to determine if the market price moves in the selected direction or not. It gives you a value of “True” or “False”."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.check_direction =
          (e) => {
            let t = e.getFieldValue("CHECK_DIRECTION");
            return [
              `Bot.checkDirection('${t}')`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
            ];
          }),
        (window.Blockly.Blocks.tick_analysis = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            args0: [
              {
                type: "field_label",
                text: (0, i.NC)(
                  "The content of this block is called on every tick"
                ),
                class: "blocklyTextTickAnalysis",
              },
              { type: "input_dummy" },
              {
                type: "input_statement",
                name: "TICKANALYSIS_STACK",
                check: null,
              },
            ],
            colour: window.Blockly.Colours.RootBlock.colour,
            colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
            colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
            tooltip: (0, i.NC)(
              "You can use this block to analyze the ticks, regardless of your trades"
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Run on every tick"),
            description: (0, i.NC)(
              "The content of this block is called on every tick. Place this block outside of any root block."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.tick_analysis =
          (e) => {
            let t =
              window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "TICKANALYSIS_STACK"
              ) || "";
            return `
    BinaryBotPrivateTickAnalysisList.push(function BinaryBotPrivateTickAnalysis() {
        ${t}
    });
`;
          }),
        (window.Blockly.Blocks.last_digit = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Last Digit"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the last digit of the latest tick"),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Last Digit"),
            description: (0, i.NC)(
              "This block gives you the last digit of the latest tick value."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.last_digit =
          () => [
            "Bot.getLastDigit()",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.lastDigitList = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Last digits list"),
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns the list of last digits of 1000 recent tick values"
            ),
            category: window.Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Last Digits List"),
            description: (0, i.NC)(
              "This block gives you a list of the last digits of the last 1000 tick values."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.lastDigitList =
          () => [
            "Bot.getLastDigitList()",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (Blockly.Blocks.stat = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Current Stat"),
            output: "Number",
            outputShape: Blockly.OUTPUT_SHAPE_ROUND,
            colour: Blockly.Colours.Base.colour,
            colourSecondary: Blockly.Colours.Base.colourSecondary,
            colourTertiary: Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the Current Stat"),
            category: Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Current Stat"),
            description: (0, i.NC)(
              "This block gives you the Current Stat value."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (Blockly.JavaScript.javascriptGenerator.forBlock.stat = () => [
          "Bot.getCurrentStat()",
          Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
        ]),
        (Blockly.Blocks.stat_list = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Current stat list"),
            output: "Array",
            outputShape: Blockly.OUTPUT_SHAPE_ROUND,
            colour: Blockly.Colours.Base.colour,
            colourSecondary: Blockly.Colours.Base.colourSecondary,
            colourTertiary: Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns the list of last digits of 1000 recent tick values"
            ),
            category: Blockly.Categories.Tick_Analysis,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Current stat list"),
            description: (0, i.NC)(
              "This block gives you a list of the cuurent stats of the last 1000 tick values."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (Blockly.JavaScript.javascriptGenerator.forBlock.stat_list = () => [
          "Bot.getStatList()",
          Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
        ]),
        (window.Blockly.Blocks.is_candle_black = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Is candle {{ input_candle }} black?", {
              input_candle: "%1",
            }),
            args0: [{ type: "input_value", name: "OHLCOBJ", check: "Candle" }],
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)('Returns "True" if the given candle is black'),
            category: window.Blockly.Categories.Candle,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Is candle black?"),
            description: (0, i.NC)(
              "This block returns “True” if the last candle is black. It can be placed anywhere on the canvas except within the Trade parameters root block."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          getRequiredValueInputs: () => ({ OHLCOBJ: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.is_candle_black =
          (e) => {
            let t =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "OHLCOBJ",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || "{}";
            return [
              `Bot.isCandleBlack(${t})`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
            ];
          }),
        (window.Blockly.Blocks.ohlc_values_in_list = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Make a list of {{ candle_property }} values from candles list {{ candle_list }}",
              { candle_property: "%1", candle_list: "%2" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "OHLCFIELD_LIST",
                options: (0, n.v)().ohlcFields,
              },
              { type: "input_value", name: "OHLCLIST" },
            ],
            output: "Array",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns a list of specific values from a given candle list"
            ),
            category: window.Blockly.Categories.Candle,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Create a list of candle values (2)"),
            description: (0, i.NC)(
              "This block gives you the selected candle value from a list of candles."
            ),
          }),
          getRequiredValueInputs: () => ({ OHLCLIST: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.ohlc_values_in_list =
          (e) => {
            let t = e.getFieldValue("OHLCFIELD_LIST") || "open",
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "OHLCLIST",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "[]";
            return [
              `Bot.candleValues(${o}, '${t}')`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
            ];
          }),
        (window.Blockly.Blocks.read_ohlc_obj = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Read {{ candle_property }} value in candle {{ input_candle }}",
              { candle_property: "%1", input_candle: "%2" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "OHLCFIELD_LIST",
                options: (0, n.v)().ohlcFields,
              },
              { type: "input_value", name: "OHLCOBJ" },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you the selected candle value."
            ),
            category: window.Blockly.Categories.Candle,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Read candle value (2)"),
            description: (0, i.NC)(
              "This block gives you the selected candle value."
            ),
          }),
          getRequiredValueInputs: () => ({ OHLCOBJ: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.read_ohlc_obj =
          (e) => {
            let t = e.getFieldValue("OHLCFIELD_LIST"),
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "OHLCOBJ",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "{}";
            return [
              `Bot.candleField(${o}, '${t}')`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
            ];
          }),
        (window.Blockly.Blocks.balance = {
          init() {
            this.jsonInit(this.definition()),
              this.getField("BALANCE_TYPE").setValidator((e) => {
                "STR" === e
                  ? this.setOutput(!0, "String")
                  : "NUM" === e && this.setOutput(!0, "Number"),
                  this.initSvg();
              });
          },
          definition: () => ({
            message0: (0, i.NC)("Balance: %1"),
            args0: [
              {
                type: "field_dropdown",
                name: "BALANCE_TYPE",
                options: (0, n.v)().lists.BALANCE_TYPE,
              },
            ],
            output: null,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("This block returns account balance"),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Account balance"),
            description: (0, i.NC)(
              "This block gives you the balance of your account either as a number or a string of text."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.balance = (
          e
        ) => {
          let t = e.getFieldValue("BALANCE_TYPE");
          return [
            `Bot.getBalance('${t}')`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ];
        }),
        (window.Blockly.Blocks.barrier_offset = {
          init() {
            this.jsonInit({
              message0: "%1",
              args0: [
                {
                  type: "field_dropdown",
                  name: "BARRIEROFFSET_IN",
                  options: (0, n.v)().BARRIER_TYPES,
                },
              ],
              output: null,
              outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              tooltip: (0, i.NC)(
                "Adds a sign to a number to create a barrier offset. (deprecated)"
              ),
              category: window.Blockly.Categories.Miscellaneous,
            });
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.barrier_offset =
          () => {}),
        (window.Blockly.Blocks.block_holder = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            args0: [
              {
                type: "field_label",
                text: "Ignore",
                class: "blocklyTextRootBlockHeader",
              },
              { type: "input_dummy" },
              { type: "input_statement", name: "USELESS_STACK", check: null },
            ],
            colour: window.Blockly.Colours.RootBlock.colour,
            colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
            colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
            tooltip: (0, i.NC)(
              "Put your blocks in here to prevent them from being removed"
            ),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Ignore"),
            description: (0, i.NC)(
              "Use this block if you want some instructions to be ignored when your bot runs. Instructions within this block won’t be executed."
            ),
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.block_holder =
          () => "");
      var s = o(51434),
        c = o(65464);
      (window.Blockly.Blocks.loader = {
        init() {
          (this.blocks_added_by_me = []),
            (this.current_url = ""),
            this.jsonInit(this.definition());
        },
        definition: () => ({
          message0: (0, i.NC)("Load block from URL: {{ input_url }}", {
            input_url: "%1",
          }),
          args0: [
            {
              type: "field_input",
              name: "URL",
              text: "http://www.example.com/block.xml",
            },
          ],
          colour: window.Blockly.Colours.Base.colour,
          colourSecondary: window.Blockly.Colours.Base.colourSecondary,
          colourTertiary: window.Blockly.Colours.Base.colourTertiary,
          tooltip: (0, i.NC)("Loads blocks from URL"),
          category: window.Blockly.Categories.Miscellaneous,
        }),
        customContextMenu(e) {
          (0, a.Z3)(e);
        },
        meta: () => ({
          display_name: (0, i.NC)("Loads from URL"),
          description: (0, i.NC)(
            "This block allows you to load blocks from a URL if you have them stored on a remote server, and they will be loaded only when your bot runs."
          ),
        }),
        onchange(e) {
          this.workspace &&
            !window.Blockly.derivWorkspace.isFlyoutVisible &&
            (e.type === window.Blockly.Events.BLOCK_CREATE &&
            e.ids.includes(this.id)
              ? ((this.current_url = this.getFieldValue("URL")),
                this.workspace
                  .getAllBlocks()
                  .filter((e) => "loader" === e.type)
                  .forEach((e) => {
                    e.id !== this.id &&
                      e.current_url === this.current_url &&
                      this.setDisabled(!0);
                  }),
                this.disabled || this.loadBlocksFromCurrentUrl())
              : e.type === window.Blockly.Events.BLOCK_CHANGE &&
                e.blockId === this.id &&
                e.newValue &&
                e.oldValue !== e.newValue &&
                (e.newValue === this.current_url
                  ? this.setDisabled(!1)
                  : this.isValidUrl(e.newValue) && !this.isKnownUrl(e.newValue)
                  ? (this.setDisabled(!1), this.loadBlocksFromCurrentUrl())
                  : this.setDisabled(!0)));
        },
        loadBlocksFromCurrentUrl() {
          (this.current_url = this.getFieldValue("URL")),
            (0, a.$9)(() => {
              this.blocks_added_by_me.forEach((e) => e.dispose());
            }),
            (0, a.oG)(this)
              .then(() => {
                c.P.emit("ui.log.success", { log_type: s.v9.LOAD_BLOCK });
              })
              .catch((e) => {
                c.P.emit("ui.log.error", e), this.setDisabled(!0);
              });
        },
        isKnownUrl(e) {
          return this.workspace
            .getAllBlocks()
            .filter((e) => "loader" === e.type)
            .some((t) => t.id !== this.id && t.current_url === e);
        },
        isValidUrl: (e) => String(e).match(/[^/]*\.[a-zA-Z]{3}$/),
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.loader =
          () => {}),
        (window.Blockly.Blocks.notify = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Notify {{ notification_type }} with sound: {{ notification_sound }} {{ input_message }}",
              {
                notification_type: "%1",
                notification_sound: "%2",
                input_message: "%3",
              }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "NOTIFICATION_TYPE",
                options: (0, n.v)().lists.NOTIFICATION_TYPE,
              },
              {
                type: "field_dropdown",
                name: "NOTIFICATION_SOUND",
                options: (0, n.v)().lists.NOTIFICATION_SOUND,
              },
              { type: "input_value", name: "MESSAGE", check: null },
            ],
            colour: window.Blockly.Colours.Special3.colour,
            colourSecondary: window.Blockly.Colours.Special3.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special3.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Displays a notification and optionally play selected sound"
            ),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Notify"),
            description: (0, i.NC)(
              "This block displays a message. You can specify the color of the message and choose from 6 different sound options."
            ),
          }),
          getRequiredValueInputs: () => ({ MESSAGE: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.notify = (
          e
        ) => {
          let t = e.getFieldValue("NOTIFICATION_TYPE"),
            o = e.getFieldValue("NOTIFICATION_SOUND"),
            a = e.getInputTargetBlock("MESSAGE"),
            l = null;
          if ("variables_get" === a.type) {
            let e = a.getFieldValue("VAR");
            l = window.Blockly.derivWorkspace.getVariableById(e).name;
          }
          let n =
            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "MESSAGE",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
            ) || `"${(0, i.NC)("<empty message>")}"`;
          return `Bot.notify({ className: 'journal__text--${t}', message: ${n}, sound: '${o}', block_id: '${e.id}', variable_name: '${l}' });
`;
        }),
        (window.Blockly.Blocks.notify_telegram = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Notify Telegram %1 Access Token: %2 Chat ID: %3 Message: %4"
            ),
            args0: [
              { type: "input_dummy" },
              { type: "input_value", name: "TELEGRAM_ACCESS_TOKEN" },
              { type: "input_value", name: "TELEGRAM_CHAT_ID" },
              { type: "input_value", name: "TELEGRAM_MESSAGE" },
            ],
            inputsInline: !0,
            colour: window.Blockly.Colours.Special3.colour,
            colourSecondary: window.Blockly.Colours.Special3.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special3.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Sends a message to Telegram"),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Notify Telegram"),
            description: (0, i.NC)(
              "This block sends a message to a Telegram channel."
            ),
          }),
          getRequiredValueInputs: () => ({
            TELEGRAM_ACCESS_TOKEN: a.cM,
            TELEGRAM_CHAT_ID: a.cM,
            TELEGRAM_MESSAGE: a.cM,
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.notify_telegram =
          (e) => {
            let t =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TELEGRAM_ACCESS_TOKEN",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "",
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TELEGRAM_CHAT_ID",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "",
              i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TELEGRAM_MESSAGE",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "";
            return t && o && i
              ? `Bot.notifyTelegram(${t}, ${o}, ${i});
`
              : "";
          }),
        (window.Blockly.Blocks.total_profit = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Total profit/loss"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the total profit/loss"),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Total profit/loss"),
            description: (0, i.NC)(
              "This block gives you the total profit/loss of your trading strategy since your bot started running. You can reset this by clicking “Clear stats” on the Transaction Stats window, or by refreshing this page in your browser."
            ),
          }),
          onchange(e) {
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) &&
              ((e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart) ||
                (e.type === window.Blockly.Events.BLOCK_CREATE &&
                  e.ids.includes(this.id))) &&
              "INITIALIZATION" === this.getRootInputTargetBlock() &&
              this.unplug(!0);
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.Blocks.total_profit_string = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Total Profit String"),
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the total profit in string format"),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Total Profit String"),
            description: (0, i.NC)("Total Profit String Description"),
          }),
          onchange: window.Blockly.Blocks.total_profit.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.total_profit =
          () => [
            "Bot.getTotalProfit(false)",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.total_profit_string =
          () => [
            "Bot.getTotalProfit(true)",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.total_runs = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Number of runs"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the number of runs"),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Number of runs"),
            description: (0, i.NC)(
              "This block gives you the total number of times your bot has run. You can reset this by clicking “Clear stats” on the Transaction Stats window, or by refreshing this page in your browser."
            ),
          }),
          onchange: window.Blockly.Blocks.total_profit.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.total_runs =
          () => [
            "Bot.getTotalRuns()",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.useless_block = {
          init() {
            this.jsonInit({
              message0: "%1",
              args0: [
                {
                  type: "field_label",
                  text: (0, i.NC)("Conversion Helper Block"),
                  class: "blocklyTextRootBlockHeader",
                },
              ],
              colour: window.Blockly.Colours.RootBlock.colour,
              colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
              colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
              tooltip: (0, i.NC)(
                "This block was required to correctly convert your old strategy."
              ),
              category: window.Blockly.Categories.Miscellaneous,
              nextStatement: null,
              previousStatement: null,
            });
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.useless_block =
          () => {}),
        (window.Blockly.Blocks.console = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Console {{ message_type }} value: {{ input_message }}",
              { message_type: "%1", input_message: "%2" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "CONSOLE_TYPE",
                options: [
                  [(0, i.NC)("Log"), "log"],
                  [(0, i.NC)("Warn"), "warn"],
                  [(0, i.NC)("Error"), "error"],
                  [(0, i.NC)("Table"), "table"],
                ],
              },
              { type: "input_value", name: "MESSAGE", check: null },
            ],
            colour: window.Blockly.Colours.Special3.colour,
            colourSecondary: window.Blockly.Colours.Special3.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special3.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Display messages in the developer’s console."),
            category: window.Blockly.Categories.Miscellaneous,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Console"),
            description: (0, i.NC)(
              "This block displays messages in the developer's console with an input that can be either a string of text, a number, boolean, or an array of data."
            ),
          }),
          getRequiredValueInputs: () => ({ MESSAGE: a.cM }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.console = (
          e
        ) => {
          let t = e.getFieldValue("CONSOLE_TYPE") || "log",
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "MESSAGE",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || `"${(0, i.NC)("<empty message>")}"`;
          return `Bot.console({ type: '${t}', message: ${o}});
`;
        }),
        (window.Blockly.Blocks.epoch = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("Seconds Since Epoch"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns the number of seconds since January 1st, 1970"
            ),
            category: window.Blockly.Categories.Time,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Second Since Epoch"),
            description: (0, i.NC)(
              "This block returns the number of seconds since January 1st, 1970."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.epoch = () => [
          "Bot.getTime()",
          window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
        ]),
        (window.Blockly.Blocks.timeout = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "{{ dummy }} {{ stack_input }} Run after {{ number }} second(s)",
              { dummy: "%1", stack_input: "%2", number: "%3" }
            ),
            args0: [
              { type: "input_dummy" },
              { type: "input_statement", name: "TIMEOUTSTACK" },
              { type: "input_value", name: "SECONDS" },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Run the blocks inside after a given number of seconds"
            ),
            category: window.Blockly.Categories.Time,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Delayed run"),
            description: (0, i.NC)(
              "This block delays execution for a given number of seconds. You can place any blocks within this block. The execution of other blocks in your strategy will be paused until the instructions in this block are carried out."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          getRequiredValueInputs: () => ({ SECONDS: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.timeout = (
          e
        ) => {
          let t = window.Blockly.JavaScript.javascriptGenerator.statementToCode(
              e,
              "TIMEOUTSTACK"
            ),
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "SECONDS",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || "1";
          return `sleep(${o});
${t}
`;
        }),
        (window.Blockly.Blocks.todatetime = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "To date/time {{ input_timestamp }} {{ dummy }}",
              { input_timestamp: "%1", dummy: "%2" }
            ),
            args0: [
              { type: "input_value", name: "TIMESTAMP", check: "Number" },
              { type: "input_dummy" },
            ],
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block converts the number of seconds since the Unix Epoch (1 January 1970) into a string of text representing the date and time."
            ),
            category: window.Blockly.Categories.Time,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Convert to date/time"),
            description: (0, i.NC)(
              "This block converts the number of seconds since the Unix Epoch (1 January 1970) into a string of text representing the date and time."
            ),
          }),
          getRequiredValueInputs: () => ({ TIMESTAMP: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.todatetime = (
          e
        ) => {
          let t = window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "TIMESTAMP",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
            ),
            o = `${(0, i.NC)("Invalid timestamp")}:`,
            a = window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
              "timestampToDateString",
              [
                `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(timestamp) {
            var datetime = new Date(timestamp * 1000);

            if (!datetime.getTime()) {
                return "${o} " + timestamp;
            }

            var getTwoDigitValue = function(input) {
                return input < 10 ? '0' + input : input;
            }

            var year    = datetime.getFullYear();
            var month   = getTwoDigitValue(datetime.getMonth() + 1);
            var day     = getTwoDigitValue(datetime.getDate());
            var hours   = getTwoDigitValue(datetime.getHours());
            var minutes = getTwoDigitValue(datetime.getMinutes());
            var seconds = getTwoDigitValue(datetime.getSeconds());

            var formatGmtOffset = function() {
                var gmt_offset_raw = datetime.getTimezoneOffset();
                var sign           = gmt_offset_raw > 0 ? '-' : '+';
                var gmt_offset     = Math.abs(gmt_offset_raw);
                var hour           = Math.floor(gmt_offset / 60);
                var minute         = gmt_offset - hour * 60;

                return 'GMT' + sign + getTwoDigitValue(hour) + getTwoDigitValue(minute);
            }

            var date_string = year + '-' + month + '-' + day;
            var time_string = hours + ':' + minutes + ':' + seconds;

            return date_string + ' ' + time_string + ' ' + formatGmtOffset();
        }`,
              ]
            );
          return [
            `${a}(${t})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        }),
        (window.Blockly.Blocks.totimestamp = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "To timestamp {{ input_datetime }} {{ dummy }}",
              { input_datetime: "%1", dummy: "%2" }
            ),
            args0: [
              { type: "input_value", name: "DATETIME" },
              { type: "input_dummy" },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Converts a string representing a date/time string into seconds since Epoch. Example: 2019-01-01 21:03:45 GMT+0800 will be converted to 1546347825. Time and time zone offset are optional."
            ),
            category: window.Blockly.Categories.Time,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Convert to timestamp"),
            description: (0, i.NC)(
              "This block converts a string of text that represents the date and time into seconds since the Unix Epoch (1 January 1970). The time and time zone offset are optional. Example: 2019-01-01 21:03:45 GMT+0800 will be converted to 1546347825."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          getRequiredValueInputs: () => ({ DATETIME: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.totimestamp = (
          e
        ) => {
          let t = window.Blockly.JavaScript.javascriptGenerator.valueToCode(
            e,
            "DATETIME",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
          );
          return [
            `Bot.dateTimeStringToTimestamp(${t})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        });
      var u = o(85872);
      (Blockly.Blocks.tick_delay = {
        init() {
          this.jsonInit(this.definition());
          let { client: e } = u.Z.instance;
          e &&
            e.is_logged_in &&
            (this.workspace_to_code =
              Blockly.JavaScript.javascriptGenerator.workspaceToCode(
                Blockly.derivWorkspace
              ));
        },
        definition: () => ({
          message0: (0, i.NC)(
            "{{ stack_input }} Run after {{ number }} tick(s)",
            { stack_input: "%1", number: "%2" }
          ),
          args0: [
            { type: "input_statement", name: "TICKDELAYSTACK" },
            { type: "input_value", name: "TICKDELAYVALUE" },
          ],
          colour: Blockly.Colours.Base.colour,
          colourSecondary: Blockly.Colours.Base.colourSecondary,
          colourTertiary: Blockly.Colours.Base.colourTertiary,
          previousStatement: null,
          nextStatement: null,
          tooltip: (0, i.NC)(
            "Run the blocks inside after a given number of ticks"
          ),
          category: Blockly.Categories.Time,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Tick Delayed run"),
          description: (0, i.NC)(
            "This block delays execution for a given number of ticks. You can place any blocks within this block. The execution of other blocks in your strategy will be paused until the instructions in this block are carried out."
          ),
        }),
        customContextMenu(e) {
          (0, a.Z3)(e);
        },
        getRequiredValueInputs() {
          return {
            TICKDELAYVALUE: (e) => {
              let t = (0, a.j3)(e);
              return "invalid_input" === t
                ? !(
                    this.workspace_to_code && this.workspace_to_code.includes(e)
                  ) &&
                    ((this.error_message = (0, i.NC)(
                      "Invalid Input {{ input_value }}.",
                      { input_value: e }
                    )),
                    !0)
                : t < 0
                ? ((this.error_message = (0, i.NC)(
                    "Values cannot be negative. Provided value: {{ input_value }}.",
                    { input_value: e }
                  )),
                  !0)
                : void 0;
            },
          };
        },
      }),
        (Blockly.JavaScript.javascriptGenerator.forBlock.tick_delay = (e) => {
          let t = Blockly.JavaScript.javascriptGenerator.statementToCode(
              e,
              "TICKDELAYSTACK"
            ),
            o =
              Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "TICKDELAYVALUE",
                Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || "1";
          return `Bot.getDelayTickValue(${o})
${t}
`;
        });
      var d = o(94576);
      (window.Blockly.Blocks.trade_definition = {
        init() {
          this.jsonInit(this.definition()),
            this.setDeletable(!1),
            (this.isInit = !1);
        },
        definition: () => ({
          message0: "%1 %2 %3",
          message1: "%1",
          message2: "%1 %2 %3",
          message3: "%1",
          message4: "%1 %2 %3",
          message5: "%1",
          message6: "%1",
          args0: [
            { type: "field_image", src: l.N$, width: 25, height: 25, alt: "T" },
            {
              type: "field_label",
              text: (0, i.NC)("1. Trade parameters"),
              class: "blocklyTextRootBlockHeader",
            },
            { type: "input_dummy" },
          ],
          args1: [{ type: "input_statement", name: "TRADE_OPTIONS" }],
          args2: [
            { type: "field_image", src: " ", width: 4, height: 25 },
            {
              type: "field_label",
              text: (0, i.NC)("Run once at start:"),
              class: "blocklyTextRootBlockHeader",
            },
            { type: "input_dummy" },
          ],
          args3: [
            { type: "input_statement", name: "INITIALIZATION", check: null },
          ],
          args4: [
            { type: "field_image", src: " ", width: 4, height: 25 },
            {
              type: "field_label",
              text: (0, i.NC)("Trade options:"),
              class: "blocklyTextRootBlockHeader",
            },
            { type: "input_dummy" },
          ],
          args5: [{ type: "input_statement", name: "SUBMARKET" }],
          args6: [{ type: "field_image", src: " ", width: 380, height: 10 }],
          colour: window.Blockly.Colours.RootBlock.colour,
          colourSecondary: window.Blockly.Colours.RootBlock.colourSecondary,
          colourTertiary: window.Blockly.Colours.RootBlock.colourTertiary,
          tooltip: (0, i.NC)(
            "Here is where you define the parameters of your contract."
          ),
          category: window.Blockly.Categories.Trade_Definition,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Trade parameters"),
          description: (0, i.NC)(
            "Here is where you define the parameters of your contract."
          ),
          key_words: (0, i.NC)("market, trade type, contract type"),
        }),
        customContextMenu(e) {
          let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
          (0, a.ei)(e, t), (0, a.Z3)(e);
        },
        onchange(e) {
          if (
            (e.type !== window.Blockly.Events.SELECTED || this.isInit
              ? null === window.Blockly.getSelected() &&
                this.isInit &&
                ((this.isInit = !1), (0, d.GZ)("keydown"))
              : ((this.isInit = !0), (0, d.tZ)("keydown")),
            !(!this.workspace || this.workspace.isDragging()) &&
              !window.Blockly.derivWorkspace.isFlyoutVisible)
          ) {
            if (
              e.type === window.Blockly.Events.BLOCK_CHANGE ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart)
            ) {
              let e = this.getBlocksInStatement("TRADE_OPTIONS");
              e.length > 0
                ? e.forEach((e) => {
                    /^trade_definition_.+$/.test(e.type) ||
                      (0, a.$9)(() => {
                        e.unplug(!0);
                      });
                  })
                : (0, a.$9)(() => {
                    this.dispose();
                  });
            }
            this.isCollapsed() && (0, a.AA)(this);
          }
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition =
          (e) => {
            let { client: t } = u.Z.instance;
            if (!t || !t.is_logged_in) throw Error("Please login");
            let { loginid: o } = t,
              i = t.getToken(o),
              a = e.getChildByType("trade_definition_market"),
              l = e.getChildByType("trade_definition_tradetype"),
              r = e.getChildByType("trade_definition_contracttype"),
              s = e.getChildByType("trade_definition_candleinterval"),
              c = e.getChildByType("trade_definition_restartonerror"),
              d = e.getChildByType("trade_definition_restartbuysell"),
              p = a.getFieldValue("SYMBOL_LIST"),
              w = l.getFieldValue("TRADETYPE_LIST"),
              y = r.getFieldValue("TYPE_LIST"),
              B = s.getFieldValue("CANDLEINTERVAL_LIST"),
              k = "FALSE" !== c.getFieldValue("RESTARTONERROR"),
              m = "FALSE" !== d.getFieldValue("TIME_MACHINE_ENABLED"),
              { opposites: h } = (0, n.v)(),
              _ =
                "both" === y
                  ? h[w.toUpperCase()].map((e) => Object.keys(e)[0])
                  : [y],
              v = window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "INITIALIZATION"
              ),
              C = window.Blockly.JavaScript.javascriptGenerator.statementToCode(
                e,
                "SUBMARKET"
              );
            return `  
    BinaryBotPrivateInit = function BinaryBotPrivateInit() {
        Bot.init('${i}', {
          symbol              : '${p}',
          contractTypes       : ${JSON.stringify(_)},
          candleInterval      : '${B || "FALSE"}',
          shouldRestartOnError: ${k},
          timeMachineEnabled  : ${m},
        });
        ${v.trim()}
    };
      BinaryBotPrivateStart = function BinaryBotPrivateStart() {
        BinaryBotPrivateHasCalledTradeOptions = false;
        Bot.highlightBlock('${e.id}');
        ${C.trim()}
      };
`;
          });
      var p = o(13604);
      (window.Blockly.Blocks.trade_definition_market = {
        init() {
          this.jsonInit({
            message0: (0, i.NC)(
              "Market: {{ input_market }} > {{ input_submarket }} > {{ input_symbol }}",
              { input_market: "%1", input_submarket: "%2", input_symbol: "%3" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "MARKET_LIST",
                options: [["", ""]],
              },
              {
                type: "field_dropdown",
                name: "SUBMARKET_LIST",
                options: [["", ""]],
              },
              {
                type: "field_dropdown",
                name: "SYMBOL_LIST",
                options: [["", ""]],
              },
            ],
            colour: window.Blockly.Colours.Special1.colour,
            colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
            previousStatement: null,
            nextStatement: null,
          }),
            this.setMovable(!1),
            this.setDeletable(!1);
        },
        customContextMenu(e) {
          let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
          (0, a.ei)(e, t), (0, a.Z3)(e);
        },
        onchange(e) {
          let t =
            -1 !==
            ["BLOCK_CREATE", "BLOCK_CHANGE", "BLOCK_DRAG"].findIndex(
              (t) => e.type === window.Blockly.Events[t]
            );
          if (
            !this.workspace ||
            window.Blockly.derivWorkspace.isFlyoutVisible ||
            this.workspace.isDragging() ||
            !t
          )
            return;
          this.enforceLimitations();
          let { active_symbols: o } =
            (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
          if (!o) return;
          let i = this.getField("MARKET_LIST"),
            a = this.getField("SUBMARKET_LIST"),
            l = this.getField("SYMBOL_LIST"),
            n = i.getValue(),
            r = a.getValue(),
            s = l.getValue(),
            c = o.getMarketDropdownOptions(),
            u = () => {
              null == i ||
                i.updateOptions(c, {
                  default_value: n,
                  should_pretend_empty: !0,
                  event_group: e.group,
                });
            };
          e.type === window.Blockly.Events.BLOCK_CREATE &&
          e.ids.includes(this.id)
            ? u()
            : e.type === window.Blockly.Events.BLOCK_CHANGE &&
              e.blockId === this.id
            ? "MARKET_LIST" === e.name
              ? a.updateOptions(o.getSubmarketDropdownOptions(n), {
                  default_value: r,
                  should_pretend_empty: !0,
                  event_group: e.group,
                })
              : "SUBMARKET_LIST" === e.name &&
                l.updateOptions(o.getSymbolDropdownOptions(r), {
                  default_value: s,
                  should_pretend_empty: !0,
                  event_group: e.group,
                })
            : e.type === window.Blockly.Events.BLOCK_DRAG &&
              !e.isStart &&
              e.blockId === this.getRootBlock().id &&
              (i.isEmpty() || a.isEmpty() || l.isEmpty()) &&
              u();
        },
        enforceLimitations() {
          (0, a.$9)(() => {
            if (this.isDescendantOf("trade_definition"))
              this.disabled && this.setDisabled(!1);
            else {
              this.unplug(!1);
              let e = this.workspace
                .getTopBlocks()
                .find((e) => "trade_definition" === e.type);
              if (e) {
                let t = e.getLastConnectionInStatement("TRADE_OPTIONS");
                t && t.connect(this.previousConnection);
              } else this.dispose();
            }
          });
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_market =
          () => {}),
        (window.Blockly.Blocks.trade_definition_tradetype = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)(
                "Trade Type: {{ trade_type_category }} > {{ trade_type }}",
                { trade_type_category: "%1", trade_type: "%2" }
              ),
              args0: [
                {
                  type: "field_dropdown",
                  name: "TRADETYPECAT_LIST",
                  options: [["", ""]],
                },
                {
                  type: "field_dropdown",
                  name: "TRADETYPE_LIST",
                  options: [["", ""]],
                },
              ],
              colour: window.Blockly.Colours.Special1.colour,
              colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
              colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          enforceLimitations:
            window.Blockly.Blocks.trade_definition_market.enforceLimitations,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_tradetype =
          () => {}),
        (window.Blockly.Blocks.trade_definition_contracttype = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)("Contract Type: {{ contract_type }}", {
                contract_type: "%1",
              }),
              args0: [
                {
                  type: "field_dropdown",
                  name: "TYPE_LIST",
                  options: [["", ""]],
                },
              ],
              colour: window.Blockly.Colours.Special1.colour,
              colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
              colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
              tooltip: (0, i.NC)(
                'If the contract type is “Both”, then the Purchase Conditions should include both Rise and Fall using the “Conditional Block"'
              ),
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange(e) {
            if (
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            )
              return;
            this.enforceLimitations();
            let t = /^dbot-load/.test(e.group);
            if (
              e.type === window.Blockly.Events.BLOCK_CHANGE &&
              "TRADETYPE_LIST" === e.name
            ) {
              let o = e.newValue,
                a = this.getField("TYPE_LIST"),
                l = [],
                s = (0, r.M)("both", o);
              s.length > 1 && l.push([(0, i.NC)("Both"), "both"]),
                l.push(...s),
                0 === l.length &&
                  l.push(...(0, n.v)().NOT_AVAILABLE_DROPDOWN_OPTIONS),
                a.updateOptions(l, {
                  event_group: e.group,
                  default_value: t ? a.getValue() : void 0,
                });
            }
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          enforceLimitations:
            window.Blockly.Blocks.trade_definition_market.enforceLimitations,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_contracttype =
          () => ""),
        (window.Blockly.Blocks.trade_definition_candleinterval = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)(
                "Default Candle Interval: {{ candle_interval_type }}",
                { candle_interval_type: "%1" }
              ),
              args0: [
                {
                  type: "field_dropdown",
                  name: "CANDLEINTERVAL_LIST",
                  options: (0, n.v)().candleIntervals.slice(1),
                },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange() {
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) && this.enforceLimitations();
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          enforceLimitations:
            window.Blockly.Blocks.trade_definition_market.enforceLimitations,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_candleinterval =
          () => {}),
        (window.Blockly.Blocks.trade_definition_restartbuysell = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)(
                "Restart buy/sell on error (disable for better performance): {{ checkbox }}",
                { checkbox: "%1" }
              ),
              args0: [
                {
                  type: "field_checkbox",
                  name: "TIME_MACHINE_ENABLED",
                  checked: !1,
                  class: "blocklyCheckbox",
                },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setMovable(!1),
              this.setDeletable(!1),
              this.setOnChange(() => {
                let e =
                  null === this || void 0 === this
                    ? void 0
                    : this.getNextBlock();
                (null == e ? void 0 : e.type) !==
                  "trade_definition_restartonerror" &&
                  (null == e || e.unplug(!0));
              });
          },
          onchange() {
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) && this.enforceLimitations();
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          enforceLimitations:
            window.Blockly.Blocks.trade_definition_market.enforceLimitations,
          required_inputs: ["TIME_MACHINE_ENABLED"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_restartbuysell =
          () => {}),
        (window.Blockly.Blocks.trade_definition_restartonerror = {
          init() {
            this.jsonInit({
              message0: (0, i.NC)(
                "Restart last trade on error (bot ignores the unsuccessful trade): {{ checkbox }}",
                { checkbox: "%1" }
              ),
              args0: [
                {
                  type: "field_checkbox",
                  name: "RESTARTONERROR",
                  checked: !0,
                  class: "blocklyCheckbox",
                },
              ],
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              previousStatement: null,
              nextStatement: null,
            }),
              this.setNextStatement(!1),
              this.setMovable(!1),
              this.setDeletable(!1);
          },
          onchange() {
            !(
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            ) && this.enforceLimitations();
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          enforceLimitations:
            window.Blockly.Blocks.trade_definition_market.enforceLimitations,
          required_inputs: ["RESTARTONERROR"],
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_restartonerror =
          () => {});
      var w = o(66175),
        y = o(89064);
      (window.Blockly.Blocks.trade_definition_tradeoptions = {
        durations: [],
        init() {
          this.jsonInit(this.definition()),
            this.setInputsInline(!0),
            this.setNextStatement(!1);
        },
        definition() {
          let e = "trade_definition_tradeoptions" === this.type;
          return {
            message0: (0, i.NC)(
              "Duration: {{ duration_unit }} {{ duration_value }}",
              { duration_unit: "%1", duration_value: "%2" }
            ),
            message1: `${
              e ? (0, i.NC)("Stake") : (0, i.NC)("Payout")
            }: %1 %2 %3`,
            args0: [
              {
                type: "field_dropdown",
                name: "DURATIONTYPE_LIST",
                options: [["", ""]],
              },
              { type: "input_value", name: "DURATION", check: "Number" },
            ],
            args1: [
              {
                type: "field_label",
                name: "CURRENCY_LIST",
                text: (0, w.O$T)((0, n.v)().lists.CURRENCY[0]),
              },
              { type: "input_value", name: "AMOUNT", check: "Number" },
              { type: "field_label", name: "AMOUNT_LIMITS", text: "" },
            ],
            colour: window.Blockly.Colours.Special1.colour,
            colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Define your trade options such as duration and stake."
            ),
            category: window.Blockly.Categories.Trade_Definition,
          };
        },
        meta: () => ({
          display_name: (0, i.NC)("Trade options"),
          description: (0, i.NC)(
            "Define your trade options such as duration and stake. Some options are only applicable for certain trade types."
          ),
        }),
        customContextMenu(e) {
          let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
          (0, a.ei)(e, t), (0, a.Z3)(e);
        },
        onchange(e) {
          if ("change" === e.type) {
            var t;
            let o = this.workspace.getBlockById(e.blockId);
            null == o ||
              null === (t = o.parentBlock_) ||
              void 0 === t ||
              t.inputList
                .filter((e) => ["DURATION", "AMOUNT"].includes(e.name))
                .forEach((e) => {
                  var t;
                  let o = e.connection.targetBlock(),
                    i =
                      null === (t = o.getFieldValue("NUM")) || void 0 === t
                        ? void 0
                        : t.toString();
                  if (null == i ? void 0 : i.startsWith("0")) {
                    let e = i.includes(".")
                      ? parseFloat(`${i}`)
                      : parseInt(`${i}`);
                    o.setFieldValue(e.toString(), "NUM");
                  }
                });
          }
          if (
            !this.workspace ||
            this.workspace.isDragging() ||
            window.Blockly.derivWorkspace.isFlyoutVisible
          )
            return;
          let o = this.workspace
            .getAllBlocks(!0)
            .find((e) => "trade_definition" === e.type);
          if (!o) return;
          let i = o.getChildByType("trade_definition_market"),
            l = o.getChildByType("trade_definition_tradetype");
          if (!i || !l) return;
          (this.selected_symbol = i.getFieldValue("SYMBOL_LIST")),
            (this.selected_market = i.getFieldValue("MARKET_LIST")),
            (this.selected_trade_type_category =
              l.getFieldValue("TRADETYPECAT_LIST")),
            (this.selected_trade_type = l.getFieldValue("TRADETYPE_LIST")),
            (this.selected_duration = this.getFieldValue("DURATIONTYPE_LIST")),
            (this.selected_barrier_types = [
              this.getFieldValue("BARRIEROFFSETTYPE_LIST") ||
                (0, n.v)().BARRIER_TYPES[0][1],
              this.getFieldValue("SECONDBARRIEROFFSETTYPE_LIST") ||
                (0, n.v)().BARRIER_TYPES[1][1],
            ]),
            ((e.type === window.Blockly.Events.BLOCK_CREATE &&
              e.ids.includes(this.id)) ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart)) &&
              ((0, a.NW)(this), this.updateAmountLimits());
          let r = /^dbot-load/.test(e.group);
          if (
            e.type === window.Blockly.Events.BLOCK_CREATE &&
            e.ids.includes(this.id)
          )
            r
              ? (this.updateBarrierInputs(!1, !1),
                this.updateDurationInput(!1, !1),
                this.updatePredictionInput(!1),
                this.updateAmountLimits())
              : (this.updateBarrierInputs(!0, !0),
                this.enforceSingleBarrierType("BARRIEROFFSETTYPE_LIST", !0),
                this.updateDurationInput(!0, !0),
                this.updatePredictionInput(!0));
          else if (e.type === window.Blockly.Events.BLOCK_CHANGE) {
            if (r)
              "TRADETYPE_LIST" === e.name &&
                (this.updateBarrierInputs(!1, !1),
                this.enforceSingleBarrierType(e.name, !0),
                this.updateDurationInput(!1, !1),
                this.updatePredictionInput(!1));
            else if (e.blockId === this.id)
              switch (e.name) {
                case "DURATIONTYPE_LIST":
                  this.updateBarrierInputs(!0, !0),
                    this.enforceSingleBarrierType("BARRIEROFFSETTYPE_LIST", !0),
                    this.updateDurationInput(!1, !0);
                  break;
                case "BARRIEROFFSETTYPE_LIST":
                case "SECONDBARRIEROFFSETTYPE_LIST":
                  this.updateBarrierInputs(!1, !0),
                    this.enforceSingleBarrierType(e.name, !1);
              }
            else
              ("SYMBOL_LIST" === e.name || "TRADETYPE_LIST" === e.name) &&
                (this.updateBarrierInputs(!0, !0),
                this.enforceSingleBarrierType(e.name, !0),
                this.updateDurationInput(!0, !0),
                this.updatePredictionInput(!0),
                this.updateAmountLimits());
          } else if (
            e.type === window.Blockly.Events.BLOCK_DRAG &&
            !e.isStart &&
            e.blockId === this.id
          ) {
            if (this.selected_duration)
              "multiplier" === this.selected_trade_type &&
                this.updateDurationInput(!1, !1);
            else {
              let e = new window.Blockly.Events.BlockCreate(this);
              (e.recordUndo = !1), window.Blockly.Events.fire(e);
            }
          }
        },
        createPredictionInput(e) {
          (0, a.$9)(() => {
            if (0 === e.length)
              this.removeInput("PREDICTION_LABEL", !0),
                this.removeInput("PREDICTION", !0);
            else if (!this.getInput("PREDICTION")) {
              this.appendDummyInput("PREDICTION_LABEL").appendField(
                (0, i.NC)("Prediction:")
              );
              let t = this.appendValueInput("PREDICTION"),
                o = this.workspace.newBlock("math_number_positive");
              o.setInputsInline(!0),
                o.setShadow(!0),
                o.setFieldValue(e[0], "NUM"),
                o.outputConnection.connect(t.connection),
                o.initSvg(),
                o.renderEfficiently();
            }
          });
        },
        createBarrierInputs(e) {
          (0, a.$9)(() => {
            let t = ["BARRIEROFFSET", "SECONDBARRIEROFFSET"];
            for (let o = 0; o < e.values.length; o++) {
              let a =
                  1 === e.values.length
                    ? (0, i.NC)("Barrier")
                    : (0, n.v)().BARRIER_LABELS[o],
                l = this.getInput(t[o]);
              if (l) l.fieldRow[0].setText(a);
              else {
                l = this.appendValueInput(t[o])
                  .appendField(a, `${t[o]}_LABEL`)
                  .appendField(
                    new window.Blockly.FieldDropdown((0, n.v)().BARRIER_TYPES),
                    `${t[o]}TYPE_LIST`
                  );
                let i = this.workspace.newBlock("math_number_positive");
                i.setInputsInline(!0),
                  i.setShadow(!0),
                  i.setFieldValue(e.values[o], "NUM"),
                  i.outputConnection.connect(l.connection),
                  i.initSvg(),
                  i.renderEfficiently();
              }
            }
            for (let o = t.length; o > e.values.length; o--)
              this.removeInput(t[o - 1], !0);
          });
        },
        updateAmountLimits() {
          let { account_limits: e } =
            (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
          if (!e) return;
          let { currency: t, landing_company_shortcode: o } =
            u.Z.instance.client;
          y.C9.getValue() ||
            e.getStakePayoutLimits(t, o, this.selected_market).then((e) => {
              var t, o, l, n;
              if (
                ["multiplier", "accumulator"].includes(this.selected_trade_type)
              )
                return;
              let r =
                  null === (t = this.getField("CURRENCY_LIST")) || void 0 === t
                    ? void 0
                    : t.getSourceBlock(),
                s =
                  null == r
                    ? void 0
                    : null === (l = r.getChildren()) || void 0 === l
                    ? void 0
                    : null === (o = l[1]) || void 0 === o
                    ? void 0
                    : o.getField("NUM");
              if (!this.getField("AMOUNT_LIMITS") && !r && !s) return;
              this.amount_limits = e;
              let { max_payout: c, min_stake: u } = e;
              c &&
                u &&
                ((0, a.$9)(() => {
                  this.setFieldValue(
                    (0, i.NC)("(min: {{min_stake}} - max: {{max_payout}})", {
                      min_stake: u,
                      max_payout: c,
                    }),
                    "AMOUNT_LIMITS"
                  );
                }),
                r &&
                  s &&
                  s.setValue(
                    null === (n = this.amount_limits) || void 0 === n
                      ? void 0
                      : n.min_stake
                  ));
            });
        },
        updateDurationInput(e, t) {
          let { contracts_for: o } =
            (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
          if (!o) return;
          "accumulator" === this.selected_trade_type &&
          this.isDescendantOf("trade_definition")
            ? (0, a.$9)(() => {
                (0, a.UR)(!1, () => {
                  let e = this.workspace.newBlock(
                    "trade_definition_accumulator"
                  );
                  e.initSvg(), e.render();
                  let t = this.workspace
                      .getTradeDefinitionBlock()
                      .getInput("SUBMARKET").connection,
                    o = e.previousConnection;
                  t.connect(o);
                  let i = e.getInput("AMOUNT"),
                    a = this.workspace.newBlock("math_number_positive");
                  a.setShadow(!0),
                    a.setFieldValue(1, "NUM"),
                    a.outputConnection.connect(i.connection),
                    a.initSvg(),
                    a.renderEfficiently();
                  let l = this.workspace.newBlock("accumulator_take_profit"),
                    n = l.getInput("AMOUNT"),
                    r = this.workspace.newBlock("math_number_positive");
                  r.setShadow(!0),
                    r.setFieldValue(0, "NUM"),
                    l.setDisabled(!0),
                    r.outputConnection.connect(n.connection),
                    r.initSvg(),
                    r.renderEfficiently(),
                    e
                      .getLastConnectionInStatement("ACCUMULATOR_PARAMS")
                      .connect(l.previousConnection),
                    l.initSvg(),
                    l.renderEfficiently(),
                    this.dispose();
                });
              })
            : "multiplier" === this.selected_trade_type &&
              this.isDescendantOf("trade_definition")
            ? (0, a.$9)(() => {
                (0, a.UR)(!1, () => {
                  let e = this.workspace.newBlock(
                    "trade_definition_multiplier"
                  );
                  e.initSvg(), e.renderEfficiently();
                  let t = this.workspace
                      .getTradeDefinitionBlock()
                      .getInput("SUBMARKET").connection,
                    o = e.previousConnection;
                  t.connect(o);
                  let i = e.getInput("AMOUNT"),
                    a = this.workspace.newBlock("math_number_positive");
                  a.setInputsInline(!0),
                    a.setShadow(!0),
                    a.setFieldValue(1, "NUM"),
                    a.outputConnection.connect(i.connection),
                    a.initSvg(),
                    a.renderEfficiently();
                  let l = this.workspace.newBlock("multiplier_take_profit"),
                    n = l.getInput("AMOUNT"),
                    r = this.workspace.newBlock("math_number_positive");
                  r.setInputsInline(!0),
                    r.setShadow(!0),
                    r.setFieldValue(0, "NUM"),
                    r.outputConnection.connect(n.connection),
                    r.initSvg(),
                    r.renderEfficiently(),
                    l.initSvg(),
                    l.renderEfficiently(),
                    e
                      .getLastConnectionInStatement("MULTIPLIER_PARAMS")
                      .connect(l.previousConnection);
                  let s = this.workspace.newBlock("multiplier_stop_loss"),
                    c = s.getInput("AMOUNT"),
                    u = this.workspace.newBlock("math_number_positive");
                  u.setInputsInline(!0),
                    u.setShadow(!0),
                    u.setFieldValue(0, "NUM"),
                    u.outputConnection.connect(c.connection),
                    u.initSvg(),
                    u.renderEfficiently(),
                    s.initSvg(),
                    s.renderEfficiently(),
                    e
                      .getLastConnectionInStatement("MULTIPLIER_PARAMS")
                      .connect(s.previousConnection),
                    this.dispose();
                });
              })
            : o
                .getDurations(this.selected_symbol, this.selected_trade_type)
                .then((o) => {
                  this.durations = o;
                  let i = this.getField("DURATIONTYPE_LIST"),
                    l = this.getInput("DURATION"),
                    n = o.map((e) => [e.display, e.unit]);
                  if (
                    (null == i ||
                      i.updateOptions(n, {
                        default_value: e ? void 0 : i.getValue(),
                      }),
                    t && l && l.connection)
                  ) {
                    let e = l.connection.targetBlock();
                    if (e && e.isShadow()) {
                      let t = o.find((e) => e.unit === this.selected_duration);
                      t &&
                        (0, a.$9)(() => {
                          e.setFieldValue(t.min, "NUM");
                        });
                    }
                  }
                });
          let {
            workspaces: {
              indentWorkspace: { x: i, y: l },
            },
          } = (0, n.v)();
          setTimeout(() => {
            window.Blockly.getMainWorkspace().cleanUp(i, l);
          }, 10);
        },
        updateBarrierInputs(e, t) {
          let { contracts_for: o } =
            (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
          if (!o) return;
          let { BARRIER_TYPES: i } = (0, n.v)();
          o.getBarriers(
            this.selected_symbol,
            this.selected_trade_type,
            this.selected_duration,
            this.selected_barrier_types
          ).then((o) => {
            this.createBarrierInputs(o);
            let l = ["BARRIEROFFSET", "SECONDBARRIEROFFSET"];
            for (let r = 0; r < o.values.length; r++) {
              let s = this.getField(`${l[r]}TYPE_LIST`),
                { ABSOLUTE_BARRIER_DROPDOWN_OPTION: c } = (0, n.v)(),
                u = e ? i[r][1] : s.getValue();
              if ("d" === this.selected_duration)
                s.updateOptions(c, { default_value: "absolute" });
              else if (o.allow_both_types || o.allow_absolute_type) {
                let e = [].concat(i, c);
                s.updateOptions(e, { default_value: u });
              } else s.updateOptions(i, { default_value: u });
              let { connection: d } = this.getInput(l[r]);
              if (t && d) {
                let e = d.targetBlock();
                if (e && e.isShadow()) {
                  let t = !1 !== o.values[r] ? o.values[r] : "";
                  (0, a.$9)(() => {
                    e.setFieldValue(t, "NUM");
                  });
                }
              }
            }
          });
        },
        updatePredictionInput(e) {
          let { contracts_for: t } =
            (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
          t &&
            t
              .getPredictionRange(
                this.selected_symbol,
                this.selected_trade_type
              )
              .then((t) => {
                if ((this.createPredictionInput(t), t.length > 0)) {
                  let { connection: o } = this.getInput("PREDICTION");
                  if (e && o) {
                    let e = o.targetBlock();
                    if (e && e.isShadow()) {
                      let o = Math.max(1, t[0]);
                      (0, a.$9)(() => {
                        e.setFieldValue(o, "NUM");
                      });
                    }
                  }
                }
              });
        },
        enforceSingleBarrierType(e, t) {
          let o = this.getFieldValue(e || ""),
            i = this.getField(
              "BARRIEROFFSETTYPE_LIST" === e
                ? "SECONDBARRIEROFFSETTYPE_LIST"
                : "BARRIEROFFSETTYPE_LIST"
            ),
            { BARRIER_TYPES: l } = (0, n.v)();
          if (i) {
            let e = -1 !== l.findIndex((e) => e[1] === o),
              n = i.getValue();
            (0, a.$9)(() => {
              if (e && ("absolute" === n || t)) {
                let e = l.find((e) => e[1] !== o);
                i.setValue(e[1]);
              } else
                "absolute" === o && "absolute" !== n && i.setValue("absolute");
            });
          }
        },
        domToMutation(e) {
          let t = "true" === e.getAttribute("has_first_barrier"),
            o = "true" === e.getAttribute("has_second_barrier"),
            i = "true" === e.getAttribute("has_prediction");
          t && o
            ? this.createBarrierInputs({ values: [1, -1] })
            : t
            ? this.createBarrierInputs({ values: [1] })
            : i && this.createPredictionInput([1]);
        },
        mutationToDom() {
          let e = document.createElement("mutation");
          return (
            e.setAttribute(
              "has_first_barrier",
              !!this.getInput("BARRIEROFFSET")
            ),
            e.setAttribute(
              "has_second_barrier",
              !!this.getInput("SECONDBARRIEROFFSET")
            ),
            e.setAttribute("has_prediction", !!this.getInput("PREDICTION")),
            e
          );
        },
        restricted_parents: ["trade_definition"],
        getRequiredValueInputs() {
          return {
            AMOUNT: (e) => {
              var t, o;
              let a = Number(e),
                l =
                  null === (t = this.amount_limits) || void 0 === t
                    ? void 0
                    : t.max_payout,
                n =
                  null === (o = this.amount_limits) || void 0 === o
                    ? void 0
                    : o.min_stake;
              return n && a < n
                ? ((this.error_message = (0, i.NC)(
                    "Please enter a stake amount that's at least {{min_stake}}.",
                    { min_stake: n }
                  )),
                  a < n)
                : l && a > l
                ? ((this.error_message = (0, i.NC)(
                    "Please enter a payout amount that's lower than {{max_payout}}.",
                    { max_payout: l }
                  )),
                  a > l)
                : ((this.error_message = (0, i.NC)(
                    "Amount must be a positive number."
                  )),
                  !isNaN(a) && a <= 0);
            },
            DURATION: (e) => {
              let t = Number(e);
              if (isNaN(t) || !this.durations.length) return !1;
              let o = this.durations.find(
                (e) => e.unit === this.selected_duration
              );
              if (o) {
                let { min: e, max: a } = o,
                  l = t >= e && t <= a;
                return (
                  e === a
                    ? (this.error_message = (0, i.NC)(
                        "Duration value is not allowed. To run the bot, please enter {{min}}.",
                        { min: e }
                      ))
                    : (this.error_message = (0, i.NC)(
                        "Duration value is not allowed. To run the bot, please enter a value between {{min}} to {{max}}.",
                        { min: e, max: a }
                      )),
                  !l
                );
              }
              return !1;
            },
          };
        },
      }),
        (window.Blockly.Blocks.trade_definition_tradeoptions_payout =
          window.Blockly.Blocks.trade_definition_tradeoptions),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_tradeoptions =
          (e) => {
            let t, o, i;
            let a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "AMOUNT",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "0",
              { currency: l } = u.Z.instance.client,
              n = e.getFieldValue("DURATIONTYPE_LIST") || "0",
              r =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "DURATION",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "0",
              s = (0, w.i4S)(l),
              c = `+(Number(${a}).toFixed(${s}))`,
              d = (e, t) =>
                /^(\d+(\.\d+)?)$/.test(t)
                  ? "absolute" === e
                    ? `'${t}'`
                    : `'${e}${t}'`
                  : "absolute" === e
                  ? t
                  : `'${e}' + ${t}`;
            return (
              e.getInput("PREDICTION") &&
                (t =
                  window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "PREDICTION",
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                  ) || "-1"),
              e.getInput("BARRIEROFFSET") &&
                (o = d(
                  e.getFieldValue("BARRIEROFFSETTYPE_LIST"),
                  window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "BARRIEROFFSET",
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                  ) || "0"
                )),
              e.getInput("SECONDBARRIEROFFSET") &&
                (i = d(
                  e.getFieldValue("SECONDBARRIEROFFSETTYPE_LIST"),
                  window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "SECONDBARRIEROFFSET",
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                  ) || "0"
                )),
              `
        Bot.start({
            limitations        : BinaryBotPrivateLimitations,
            duration           : ${r},
            duration_unit      : '${n}',
            currency           : '${l}',
            amount             : ${c},
            prediction         : ${t || "undefined"},
            barrierOffset      : ${o || "undefined"},
            secondBarrierOffset: ${i || "undefined"},
            basis              : '${
              "trade_definition_tradeoptions" === e.type ? "stake" : "payout"
            }',
        });
        BinaryBotPrivateHasCalledTradeOptions = true;
    `
            );
          }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_tradeoptions_payout =
          window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_tradeoptions),
        (window.Blockly.Blocks.trade_definition_multiplier = {
          init() {
            this.jsonInit(this.definition()), this.setNextStatement(!1);
          },
          definition: () => ({
            message0: (0, i.NC)("Multiplier: {{ multiplier }}", {
              multiplier: "%1",
            }),
            message1: `${(0, i.NC)("Stake")}: %1 %2 %3`,
            message2: "%1",
            message3: "%1",
            args0: [
              {
                type: "field_dropdown",
                name: "MULTIPLIERTYPE_LIST",
                options: [["", ""]],
              },
            ],
            args1: [
              {
                type: "field_label",
                name: "CURRENCY_LIST",
                text: (0, w.O$T)((0, n.v)().lists.CURRENCY[0]),
              },
              { type: "input_value", name: "AMOUNT", check: "Number" },
              { type: "field_label", name: "AMOUNT_LIMITS", text: "" },
            ],
            args2: [{ type: "input_dummy" }],
            args3: [{ type: "input_statement", name: "MULTIPLIER_PARAMS" }],
            inputsInline: !0,
            colour: window.Blockly.Colours.Special1.colour,
            colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "Define your trade options such as multiplier and stake."
            ),
            category: window.Blockly.Categories.Trade_Definition,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Multiplier trade options"),
            description: (0, i.NC)(
              "Define your trade options such as multiplier and stake. This block can only be used with the multipliers trade type. If you select another trade type, this block will be replaced with the Trade options block."
            ),
          }),
          validateBlocksInStatement() {
            let e = this.getBlocksInStatement("MULTIPLIER_PARAMS");
            if (e.length > 0) {
              let t = [];
              e.forEach((e) => {
                t.push(e.type);
                let o = e.childValueToCode("multiplier_take_profit", "AMOUNT"),
                  i = e.childValueToCode("multiplier_stop_loss", "AMOUNT");
                (o <= 0 || i <= 0) && e.setDisabled(!0),
                  "multiplier_stop_loss" === e.type &&
                    i > 0 &&
                    e.setDisabled(!1),
                  "multiplier_take_profit" === e.type &&
                    o > 0 &&
                    e.setDisabled(!1),
                  (/^multiplier_.+$/.test(e.type) &&
                    new Set(t).size === t.length) ||
                    (0, a.$9)(() => {
                      e.unplug(!0);
                    });
              });
            }
          },
          onchange(e) {
            if (
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            )
              return;
            let t = this.workspace
              .getAllBlocks(!0)
              .find((e) => "trade_definition" === e.type);
            if (!t) return;
            let o = t.getChildByType("trade_definition_market"),
              i = t.getChildByType("trade_definition_tradetype");
            if (!o || !i) return;
            (this.selected_symbol = o.getFieldValue("SYMBOL_LIST")),
              (this.selected_market = o.getFieldValue("MARKET_LIST")),
              (this.selected_trade_type_category =
                i.getFieldValue("TRADETYPECAT_LIST")),
              (this.selected_trade_type = i.getFieldValue("TRADETYPE_LIST")),
              (this.selected_multiplier = this.getFieldValue(
                "MULTIPLIERTYPE_LIST"
              ));
            let l = /^dbot-load/.test(e.group);
            if (
              e.type === window.Blockly.Events.BLOCK_CREATE &&
              e.ids.includes(this.id)
            ) {
              (0, a.NW)(this),
                l
                  ? this.updateMultiplierInput(!1)
                  : this.updateMultiplierInput(!0);
              return;
            }
            if (e.type === window.Blockly.Events.BLOCK_CHANGE) {
              (0, a.NW)(this),
                this.validateBlocksInStatement(),
                l
                  ? "TRADETYPE_LIST" === e.name &&
                    this.updateMultiplierInput(!1)
                  : e.blockId === this.id
                  ? "MULTIPLIERTYPE_LIST" === e.name &&
                    this.updateMultiplierInput(!1)
                  : ("SYMBOL_LIST" === e.name || "TRADETYPE_LIST" === e.name) &&
                    this.updateMultiplierInput(!0);
              return;
            }
            if (
              e.type === window.Blockly.Events.BLOCK_DRAG &&
              !e.isStart &&
              (this.validateBlocksInStatement(), e.blockId === this.id)
            ) {
              if (this.selected_multiplier)
                "multiplier" !== this.selected_trade_type &&
                  this.updateMultiplierInput(!0);
              else {
                let e = new window.Blockly.Events.BlockCreate(this);
                (e.recordUndo = !1), window.Blockly.Events.fire(e);
              }
            }
          },
          updateMultiplierInput(e) {
            let { contracts_for: t } =
              (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
            if ("multiplier" === this.selected_trade_type) {
              var o, i;
              null == t ||
                null === (i = t.getMultiplierRange) ||
                void 0 === i ||
                null ===
                  (o = i.call(
                    t,
                    this.selected_symbol,
                    this.selected_trade_type
                  )) ||
                void 0 === o ||
                o.then((t) => {
                  if (t.length > 0) {
                    let o = this.getField("MULTIPLIERTYPE_LIST"),
                      i = t.map((e) => {
                        let t = e.toString();
                        return [t, t];
                      });
                    null == o ||
                      o.updateOptions(i, {
                        default_value: e ? void 0 : o.getValue(),
                      });
                  }
                });
              return;
            }
            this.isDescendantOf("trade_definition") &&
              (0, a.$9)(() => {
                (0, a.UR)(!1, () => {
                  let {
                      workspaces: {
                        indentWorkspace: { x: e, y: t },
                      },
                    } = (0, n.v)(),
                    o = this.workspace.newBlock(
                      "trade_definition_tradeoptions"
                    );
                  o.initSvg(), o.renderEfficiently();
                  let i = this.workspace
                      .getTradeDefinitionBlock()
                      .getInput("SUBMARKET").connection,
                    a = o.previousConnection;
                  i.connect(a);
                  let l = o.getInput("DURATION"),
                    r = this.workspace.newBlock("math_number_positive");
                  r.setShadow(!0),
                    r.outputConnection.connect(l.connection),
                    r.initSvg(),
                    r.renderEfficiently();
                  let s = o.getInput("AMOUNT"),
                    c = this.workspace.newBlock("math_number_positive");
                  c.setShadow(!0),
                    c.setFieldValue(1, "NUM"),
                    c.outputConnection.connect(s.connection),
                    c.initSvg(),
                    c.renderEfficiently(),
                    this.dispose(),
                    window.Blockly.getMainWorkspace().cleanUp(e, t);
                });
              });
          },
          customContextMenu(e) {
            let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
            (0, a.ei)(e, t), (0, a.Z3)(e);
          },
          restricted_parents: ["trade_definition"],
          getRequiredValueInputs() {
            return {
              AMOUNT: (e) => {
                var t, o;
                let a = Number(e),
                  l =
                    null === (t = this.amount_limits) || void 0 === t
                      ? void 0
                      : t.max_payout,
                  n =
                    null === (o = this.amount_limits) || void 0 === o
                      ? void 0
                      : o.min_stake;
                return n && a < n
                  ? ((this.error_message = (0, i.NC)(
                      "Please enter a stake amount that's at least {{min_stake}}.",
                      { min_stake: n }
                    )),
                    a < n)
                  : l && a > l
                  ? ((this.error_message = (0, i.NC)(
                      "Please enter a payout amount that's lower than {{max_payout}}.",
                      { max_payout: l }
                    )),
                    a > l)
                  : ((this.error_message = (0, i.NC)(
                      "Amount must be a positive number."
                    )),
                    !isNaN(a) && a <= 0);
              },
            };
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_multiplier =
          (e) => {
            var t, o;
            let i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "AMOUNT",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "0",
              { currency: a } = u.Z.instance.client,
              { setContractUpdateConfig: l } = u.Z.instance,
              n = e.getFieldValue("MULTIPLIERTYPE_LIST") || "1",
              r =
                !(null === (t = e.getChildByType("multiplier_stop_loss")) ||
                void 0 === t
                  ? void 0
                  : t.disabled) &&
                e.childValueToCode("multiplier_stop_loss", "AMOUNT"),
              s =
                !(null === (o = e.getChildByType("multiplier_take_profit")) ||
                void 0 === o
                  ? void 0
                  : o.disabled) &&
                e.childValueToCode("multiplier_take_profit", "AMOUNT"),
              c = {
                stop_loss: r ? `+(Number(${r}).toFixed(2))` : void 0,
                take_profit: s ? `+(Number(${s}).toFixed(2))` : void 0,
              };
            l(s, r);
            let d = (0, w.i4S)(a),
              p = `+(Number(${i}).toFixed(${d}))`;
            return `
        Bot.start({
            limitations        : BinaryBotPrivateLimitations,
            multiplier         : ${n},
            currency           : '${a}',
            amount             : ${p},
            limit_order        : ${JSON.stringify(c)},
            basis              : 'stake',
            stop_loss          : ${c.stop_loss},
            take_profit        : ${c.take_profit},
        });
        BinaryBotPrivateHasCalledTradeOptions = true;
    `;
          });
      let B = (0, i.NC)(
        "Your contract is closed automatically when your loss is more than or equals to this amount. This block can only be used with the multipliers trade type."
      );
      (window.Blockly.Blocks.multiplier_stop_loss = {
        init() {
          this.jsonInit(this.definition());
        },
        definition: () => ({
          message0: (0, i.NC)("Stop Loss: {{ currency }} {{ stop_loss }}", {
            currency: "%1",
            stop_loss: "%2",
          }),
          args0: [
            {
              type: "field_label",
              name: "CURRENCY_LIST",
              text: (0, w.O$T)((0, n.v)().lists.CURRENCY[0]),
            },
            { type: "input_value", name: "AMOUNT", check: "Number" },
          ],
          colour: window.Blockly.Colours.Base.colour,
          colourSecondary: window.Blockly.Colours.Base.colourSecondary,
          colourTertiary: window.Blockly.Colours.Base.colourTertiary,
          previousStatement: null,
          nextStatement: null,
          tooltip: B,
          category: window.Blockly.Categories.Trade_Definition,
        }),
        customContextMenu(e) {
          (0, a.Z3)(e);
        },
        meta: () => ({
          display_name: (0, i.NC)("Stop loss (Multiplier)"),
          description: B,
        }),
        onchange(e) {
          !(
            !this.workspace ||
            window.Blockly.derivWorkspace.isFlyoutVisible ||
            this.workspace.isDragging()
          ) &&
            ((e.type === window.Blockly.Events.BLOCK_CREATE &&
              e.ids.includes(this.id)) ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart) ||
              (e.type === window.Blockly.Events.BLOCK_CHANGE && !e.isStart)) &&
            (0, a.NW)(this);
        },
        restricted_parents: ["trade_definition_multiplier"],
        getRequiredValueInputs() {
          return this.getInput("AMOUNT").connection.targetBlock()
            ? {
                AMOUNT: (e) => {
                  let t = Number(e);
                  return (
                    (this.error_message = (0, i.NC)(
                      "Stop loss must be a positive number."
                    )),
                    !isNaN(t) && t <= 0
                  );
                },
              }
            : {};
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.multiplier_stop_loss =
          () => {});
      let k = (0, i.NC)(
        "Your contract is closed automatically when your profit is more than or equals to this amount. This block can only be used with the accumulator trade type."
      );
      (window.Blockly.Blocks.accumulator_take_profit = {
        init() {
          this.jsonInit(this.definition());
        },
        definition: () => ({
          message0: (0, i.NC)("Take Profit: {{ currency }} {{ take_profit }}", {
            currency: "%1",
            take_profit: "%2",
          }),
          args0: [
            {
              type: "field_label",
              name: "CURRENCY_LIST",
              text: (0, w.O$T)((0, n.v)().lists.CURRENCY[0]),
            },
            { type: "input_value", name: "AMOUNT", check: "Number" },
          ],
          colour: window.Blockly.Colours.Base.colour,
          colourSecondary: window.Blockly.Colours.Base.colourSecondary,
          colourTertiary: window.Blockly.Colours.Base.colourTertiary,
          previousStatement: null,
          nextStatement: null,
          tooltip: k,
          category: window.Blockly.Categories.Trade_Definition,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Take Profit (Accumulator)"),
          description: k,
        }),
        onchange(e) {
          !(
            !this.workspace ||
            window.Blockly.derivWorkspace.isFlyoutVisible ||
            this.workspace.isDragging()
          ) &&
            ((e.type === window.Blockly.Events.BLOCK_CREATE &&
              e.ids.includes(this.id)) ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart) ||
              (e.type === window.Blockly.Events.BLOCK_CHANGE && !e.isStart)) &&
            (0, a.NW)(this);
        },
        customContextMenu(e) {
          let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
          (0, a.ei)(e, t), (0, a.Z3)(e);
        },
        restricted_parents: ["trade_definition_accumulator"],
        getRequiredValueInputs() {
          return this.getInput("AMOUNT").connection.targetBlock()
            ? {
                AMOUNT: (e) => {
                  let t = Number(e);
                  return (
                    (this.error_message = (0, i.NC)(
                      "Take profit must be a positive number."
                    )),
                    !isNaN(t) && t <= 0
                  );
                },
              }
            : {};
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.accumulator_take_profit =
          () => {});
      let m = (0, i.NC)(
        "Your contract is closed automatically when your profit is more than or equals to this amount. This block can only be used with the multipliers trade type."
      );
      (window.Blockly.Blocks.multiplier_take_profit = {
        init() {
          this.jsonInit(this.definition());
        },
        definition: () => ({
          message0: (0, i.NC)("Take Profit: {{ currency }} {{ take_profit }}", {
            currency: "%1",
            take_profit: "%2",
          }),
          args0: [
            {
              type: "field_label",
              name: "CURRENCY_LIST",
              text: (0, w.O$T)((0, n.v)().lists.CURRENCY[0]),
            },
            { type: "input_value", name: "AMOUNT", check: "Number" },
          ],
          colour: window.Blockly.Colours.Base.colour,
          colourSecondary: window.Blockly.Colours.Base.colourSecondary,
          colourTertiary: window.Blockly.Colours.Base.colourTertiary,
          previousStatement: null,
          nextStatement: null,
          tooltip: m,
          category: window.Blockly.Categories.Trade_Definition,
        }),
        customContextMenu(e) {
          (0, a.Z3)(e);
        },
        meta: () => ({
          display_name: (0, i.NC)("Take Profit (Multiplier)"),
          description: m,
        }),
        onchange(e) {
          !(
            !this.workspace ||
            window.Blockly.derivWorkspace.isFlyoutVisible ||
            this.workspace.isDragging()
          ) &&
            ((e.type === window.Blockly.Events.BLOCK_CREATE &&
              e.ids.includes(this.id)) ||
              (e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart) ||
              (e.type === window.Blockly.Events.BLOCK_CHANGE && !e.isStart)) &&
            (0, a.NW)(this);
        },
        restricted_parents: ["trade_definition_multiplier"],
        getRequiredValueInputs() {
          return this.getInput("AMOUNT").connection.targetBlock()
            ? {
                AMOUNT: (e) => {
                  let t = Number(e);
                  return (
                    (this.error_message = (0, i.NC)(
                      "Take profit must be a positive number."
                    )),
                    !isNaN(t) && t <= 0
                  );
                },
              }
            : {};
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.multiplier_take_profit =
          () => {});
      var h = o(63999);
      (window.Blockly.Blocks.trade_definition_accumulator = {
        init() {
          this.jsonInit(this.definition()), this.setNextStatement(!1);
        },
        definition: () => ({
          message0: (0, i.NC)("Growth Rate: {{ accumulator }}", {
            accumulator: "%1",
          }),
          message1: `${(0, i.NC)("Stake")}: %1 %2`,
          message2: "%1",
          message3: "%1",
          args0: [
            {
              type: "field_dropdown",
              name: "GROWTHRATE_LIST",
              options: [["", ""]],
            },
          ],
          args1: [
            {
              type: "field_label",
              name: "CURRENCY_LIST",
              text: (0, w.O$T)((0, n.v)().lists.CURRENCY[0]),
            },
            { type: "input_value", name: "AMOUNT", check: "Number" },
          ],
          args2: [{ type: "input_dummy" }],
          args3: [{ type: "input_statement", name: "ACCUMULATOR_PARAMS" }],
          colour: window.Blockly.Colours.Special1.colour,
          colourSecondary: window.Blockly.Colours.Special1.colourSecondary,
          colourTertiary: window.Blockly.Colours.Special1.colourTertiary,
          previousStatement: null,
          nextStatement: null,
          tooltip: (0, i.NC)(
            "Define your trade options, such as accumulator and stake."
          ),
          category: window.Blockly.Categories.Trade_Definition,
        }),
        meta: () => ({
          display_name: (0, i.NC)("Accumulator trade options"),
          description: (0, i.NC)(
            "Define your trade options such as accumulator and stake. This block can only be used with the accumulator trade type. If you select another trade type, this block will be replaced with the Trade options block."
          ),
        }),
        validateBlocksInStatement() {
          let e = this.getBlocksInStatement("ACCUMULATOR_PARAMS");
          if (e.length > 0) {
            let t = [];
            e.forEach((e) => {
              t.push(e.type);
              let o = e.childValueToCode("accumulator_take_profit", "AMOUNT");
              o <= 0 && e.setDisabled(!0),
                "accumulator_take_profit" === e.type &&
                  o > 0 &&
                  e.setDisabled(!1),
                (/^accumulator_.+$/.test(e.type) &&
                  new Set(t).size === t.length) ||
                  (0, a.$9)(() => {
                    e.unplug(!0);
                  });
            });
          }
        },
        onchange(e) {
          if (
            !this.workspace ||
            window.Blockly.derivWorkspace.isFlyoutVisible ||
            this.workspace.isDragging()
          )
            return;
          (0, h.Gh)(this);
          let t = this.workspace
            .getAllBlocks(!0)
            .find((e) => "trade_definition" === e.type);
          if (!t) return;
          let o = t.getChildByType("trade_definition_market"),
            i = t.getChildByType("trade_definition_tradetype");
          if (!o || !i) return;
          (this.selected_symbol = o.getFieldValue("SYMBOL_LIST")),
            (this.selected_market = o.getFieldValue("MARKET_LIST")),
            (this.selected_trade_type_category =
              i.getFieldValue("TRADETYPECAT_LIST")),
            (this.selected_trade_type = i.getFieldValue("TRADETYPE_LIST")),
            (this.selected_growth_rate = this.getFieldValue("GROWTHRATE_LIST"));
          let l = /^dbot-load/.test(e.group);
          if (
            e.type === window.Blockly.Events.BLOCK_CREATE &&
            e.ids.includes(this.id)
          ) {
            (0, a.NW)(this),
              l
                ? this.updateAccumulatorInput(!1)
                : this.updateAccumulatorInput(!0);
            return;
          }
          if (e.type === window.Blockly.Events.BLOCK_CHANGE) {
            (0, a.NW)(this),
              this.validateBlocksInStatement(),
              l
                ? "TRADETYPE_LIST" === e.name && this.updateAccumulatorInput(!1)
                : e.blockId === this.id
                ? "GROWTHRATE_LIST" === e.name &&
                  this.updateAccumulatorInput(!1)
                : ("SYMBOL_LIST" === e.name || "TRADETYPE_LIST" === e.name) &&
                  this.updateAccumulatorInput(!0);
            return;
          }
          if (
            e.type === window.Blockly.Events.BLOCK_DRAG &&
            !e.isStart &&
            (this.validateBlocksInStatement(), e.blockId === this.id)
          ) {
            if (this.selected_growth_rate)
              "accumulator" !== this.selected_trade_type &&
                this.updateAccumulatorInput(!0);
            else {
              let e = new window.Blockly.Events.Create(this);
              (e.recordUndo = !1), window.Blockly.Events.fire(e);
            }
          }
        },
        updateAmountLimits:
          window.Blockly.Blocks.trade_definition_tradeoptions
            .updateAmountLimits,
        updateAccumulatorInput(e) {
          let { contracts_for: t } =
            (null === p.Z || void 0 === p.Z ? void 0 : p.Z.instance) ?? {};
          if ("accumulator" === this.selected_trade_type) {
            var o, i;
            null == t ||
              null === (i = t.getAccumulationRange) ||
              void 0 === i ||
              null === (o = i.call(t)) ||
              void 0 === o ||
              o.then((t) => {
                if (t.length > 0) {
                  let o = this.getField("GROWTHRATE_LIST"),
                    i = t.map((e) => {
                      let t = e.toString();
                      return [`${100 * t}%`, t];
                    });
                  null == o ||
                    o.updateOptions(i, {
                      default_value: e ? void 0 : o.getValue(),
                    });
                }
              });
            return;
          }
          this.isDescendantOf("trade_definition") &&
            (0, a.$9)(() => {
              (0, a.UR)(!1, () => {
                let {
                    workspaces: {
                      indentWorkspace: { x: e, y: t },
                    },
                  } = (0, n.v)(),
                  o = this.workspace.newBlock("trade_definition_tradeoptions");
                o.initSvg(), o.render();
                let i = this.workspace
                    .getTradeDefinitionBlock()
                    .getInput("SUBMARKET").connection,
                  a = o.previousConnection;
                i.connect(a);
                let l = o.getInput("DURATION"),
                  r = this.workspace.newBlock("math_number_positive");
                r.setShadow(!0),
                  r.outputConnection.connect(l.connection),
                  r.initSvg(),
                  r.render(!0);
                let s = o.getInput("AMOUNT"),
                  c = this.workspace.newBlock("math_number_positive");
                c.setShadow(!0),
                  c.setFieldValue(1, "NUM"),
                  c.outputConnection.connect(s.connection),
                  c.initSvg(),
                  c.render(!0),
                  this.dispose(),
                  window.Blockly.derivWorkspace.cleanUp(e, t);
              });
            });
        },
        customContextMenu(e) {
          let t = [(0, i.NC)("Enable Block"), (0, i.NC)("Disable Block")];
          (0, a.ei)(e, t), (0, a.Z3)(e);
        },
        restricted_parents: ["trade_definition"],
        getRequiredValueInputs() {
          return {
            AMOUNT: (e) => {
              var t, o;
              let a = Number(e),
                l =
                  null === (t = this.amount_limits) || void 0 === t
                    ? void 0
                    : t.max_payout,
                n =
                  null === (o = this.amount_limits) || void 0 === o
                    ? void 0
                    : o.min_stake;
              return n && a < n
                ? ((this.error_message = (0, i.NC)(
                    "Please enter a stake amount that's at least {{min_stake}}.",
                    { min_stake: n }
                  )),
                  a < n)
                : l && a > l
                ? ((this.error_message = (0, i.NC)(
                    "Please enter a payout amount that's lower than {{max_payout}}.",
                    { max_payout: l }
                  )),
                  a > l)
                : ((this.error_message = (0, i.NC)(
                    "Amount must be a positive number."
                  )),
                  !isNaN(a) && a <= 0);
            },
          };
        },
      }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.trade_definition_accumulator =
          (e) => {
            var t;
            let o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "AMOUNT",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "0",
              { currency: i } = u.Z.instance.client,
              { setContractUpdateConfig: a } = u.Z.instance,
              l = e.getFieldValue("GROWTHRATE_LIST") || "1",
              n =
                !(null === (t = e.getChildByType("accumulator_take_profit")) ||
                void 0 === t
                  ? void 0
                  : t.disabled) &&
                e.childValueToCode("accumulator_take_profit", "AMOUNT"),
              r = { take_profit: n ? `+(Number(${n}).toFixed(2))` : void 0 };
            a(void 0, n);
            let s = (0, w.i4S)(i),
              c = `+(Number(${o}).toFixed(${s}))`;
            return `
        Bot.start({
            limitations        : BinaryBotPrivateLimitations,
            growth_rate        : ${l},
            currency           : '${i}',
            amount             : ${c},
            limit_order        : ${JSON.stringify(r)},
            basis              : 'stake',
            take_profit          : ${r.take_profit},
        });
        BinaryBotPrivateHasCalledTradeOptions = true;
    `;
          }),
        (window.Blockly.Blocks.logic_compare = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            args0: [
              { type: "input_value", name: "A" },
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  ["=", "EQ"],
                  ["≠", "NEQ"],
                  ["‏<", "LT"],
                  ["‏≤", "LTE"],
                  ["‏>", "GT"],
                  ["‏≥", "GTE"],
                ],
              },
              { type: "input_value", name: "B" },
            ],
            inputsInline: !0,
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Compares two values"),
            category: window.Blockly.Categories.Logic,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Compare"),
            description: (0, i.NC)(
              "This block compares two values and is used to build a conditional structure."
            ),
          }),
          getRequiredValueInputs: () => ({ A: null, B: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.logic_compare =
          (e) => {
            let t = {
                EQ: "==",
                NEQ: "!=",
                LT: "<",
                LTE: "<=",
                GT: ">",
                GTE: ">=",
              }[e.getFieldValue("OP") || "EQ"],
              o = ["==", "!="].includes(t)
                ? window.Blockly.JavaScript.javascriptGenerator.ORDER_EQUALITY
                : window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_RELATIONAL,
              i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "A",
                  o
                ) || "false",
              a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "B",
                  o
                ) || "false";
            return [`${i} ${t} ${a}`, o];
          }),
        (window.Blockly.Blocks.controls_if = {
          init() {
            (this.value_connections = [null]),
              (this.statement_connections = [null]),
              (this.else_statement_connection = null),
              (this.else_if_count = 0),
              (this.else_count = 0),
              this.jsonInit(this.definition()),
              this.updateShape();
          },
          definition: () => ({
            message0: (0, i.NC)("if {{ condition }} then", { condition: "%1" }),
            message1: "%1",
            message2: "%1",
            args0: [{ type: "input_value", name: "IF0", check: "Boolean" }],
            args1: [{ type: "field_image", src: " ", width: 150, height: 1 }],
            args2: [{ type: "input_statement", name: "DO0" }],
            inputsInline: !0,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Conditional block"),
            category: window.Blockly.Categories.Logic,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Conditional block"),
            description: (0, i.NC)(
              "This block evaluates a statement and will perform an action only when the statement is true."
            ),
          }),
          mutationToDom() {
            let e = document.createElement("mutation");
            return (
              this.else_if_count &&
                e.setAttribute("elseif", this.else_if_count),
              this.else_count && e.setAttribute("else", 1),
              e
            );
          },
          domToMutation(e) {
            (this.else_if_count = parseInt(e.getAttribute("elseif")) || 0),
              (this.else_count = parseInt(e.getAttribute("else")) || 0),
              this.rebuildShape();
          },
          rebuildShape() {
            var e, t;
            let o = [null],
              i = [null],
              a =
                (null === (t = this.getInput("ELSE")) || void 0 === t
                  ? void 0
                  : null === (e = t.connection) || void 0 === e
                  ? void 0
                  : e.targetConnection) || null,
              l = 1;
            for (;;) {
              let e = this.getIfInputNames(l),
                t = this.getInput(e.IF);
              if (!t) break;
              let a = this.getInput(e.DO);
              o.push(t.connection.targetConnection),
                i.push(a.connection.targetConnection),
                l++;
            }
            this.updateShape(), this.reconnectChildBlocks(o, i, a);
          },
          update(e) {
            window.Blockly.Events.setGroup(!0);
            let t = this.mutationToDom(),
              o = t && window.Blockly.Xml.domToText(t),
              i = this.rendered;
            (this.rendered = !1),
              e && e.call(this),
              this.updateShape(),
              (this.rendered = i),
              this.initSvg();
            let a = window.Blockly.Events.getGroup(),
              l = this.mutationToDom(),
              n = l && window.Blockly.Xml.domToText(l);
            if (o !== n) {
              let e = new window.Blockly.Events.BlockChange(
                this,
                "mutation",
                null,
                o,
                n
              );
              window.Blockly.Events.fire(e),
                setTimeout(() => {
                  window.Blockly.Events.setGroup(a),
                    this.bumpNeighbours(),
                    window.Blockly.Events.setGroup(!1);
                }, window.Blockly.BUMP_DELAY);
            }
            this.rendered && this.renderEfficiently(),
              window.Blockly.Events.setGroup(!1);
          },
          updateShape() {
            this.getInput("ELSE") &&
              (this.removeInput("ELSE"),
              this.removeInput("ELSE_LABEL"),
              this.removeInput("DELETE_ELSE"));
            let e = 1;
            for (;;) {
              let t = this.getIfInputNames(e);
              if (!this.getInput(t.IF)) break;
              this.removeInput(t.IF_LABEL),
                this.removeInput(t.IF),
                this.removeInput(t.THEN_LABEL),
                this.removeInput(t.DELETE_ICON),
                this.removeInput(t.DO),
                e++;
            }
            this.getInput("MUTATOR") && this.removeInput("MUTATOR");
            for (let e = 1; e <= this.else_if_count; e++) {
              let t = this.getIfInputNames(e),
                o = () => this.modifyElseIf(!1, e);
              this.appendDummyInput(t.IF_LABEL).appendField(
                (0, i.NC)("else if")
              ),
                this.appendValueInput(t.IF).setCheck("Boolean"),
                this.appendDummyInput(t.THEN_LABEL).appendField(
                  (0, i.NC)("then")
                ),
                this.appendDummyInput(t.DELETE_ICON).appendField(
                  new window.Blockly.FieldImage(l.fK, 24, 24, "-", o)
                ),
                this.appendStatementInput(t.DO);
            }
            this.else_count > 0 &&
              (this.appendDummyInput("ELSE_LABEL").appendField(
                (0, i.NC)("else")
              ),
              this.appendDummyInput("DELETE_ELSE").appendField(
                new window.Blockly.FieldImage(
                  l.fK,
                  24,
                  24,
                  "-",
                  () => this.modifyElse(!1),
                  !1
                )
              ),
              this.appendStatementInput("ELSE")),
              this.appendDummyInput("MUTATOR").appendField(
                new window.Blockly.FieldImage(
                  l.M8,
                  24,
                  24,
                  "+",
                  () => {
                    0 === this.else_count
                      ? this.modifyElse(!0)
                      : (this.else_if_count || (this.else_if_count = 0),
                        this.modifyElseIf(!0));
                  },
                  !1
                )
              ),
              this.initSvg(),
              this.queueRender();
          },
          storeConnections() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 0;
            (this.value_connections = [null]),
              (this.statement_connections = [null]),
              (this.else_statement_connection = null);
            for (let t = 1; t <= this.else_if_count; t++)
              if (e !== t) {
                let e = this.getIfInputNames(t);
                this.value_connections.push(
                  this.getInput(e.IF).connection.targetConnection
                ),
                  this.statement_connections.push(
                    this.getInput(e.DO).connection.targetConnection
                  );
              }
            let t = this.getInput("ELSE");
            t &&
              (this.else_statement_connection = t.connection.targetConnection);
          },
          reconnectChildBlocks(e, t, o) {
            let i = e ?? this.value_connections,
              a = t ?? this.statement_connections,
              l = o ?? this.else_statement_connection;
            for (let e = 1; e <= this.else_if_count; e++) {
              let t = this.getIfInputNames(e),
                o = i[e],
                l = a[e],
                n = this.getInput(t.IF);
              o && n && (n.connection.disconnect(), n.connection.connect(o));
              let r = this.getInput(t.DO);
              l && r && (r.connection.disconnect(), r.connection.connect(l));
            }
            let n = this.getInput("ELSE");
            l && n && (n.connection.disconnect(), n.connection.connect(l));
          },
          modifyElse(e) {
            this.storeConnections(),
              this.update(() => {
                this.else_count += e ? 1 : -1;
              }),
              this.reconnectChildBlocks();
          },
          modifyElseIf(e, t) {
            this.storeConnections(t),
              this.update(() => {
                this.else_if_count += e ? 1 : -1;
              }),
              this.reconnectChildBlocks();
          },
          getRequiredValueInputs() {
            let e = {};
            return (
              this.inputList
                .filter((e) => /^IF[0-9]*?$/.test(e.name))
                .forEach((t) => (e[t.name] = null)),
              e
            );
          },
          getIfInputNames: (e) => ({
            IF_LABEL: `IF_LABEL${e}`,
            IF: `IF${e}`,
            THEN_LABEL: `THEN_LABEL${e}`,
            DELETE_ICON: `DELETE_ICON${e}`,
            DO: `DO${e}`,
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.controls_if = (
          e
        ) => {
          let t = 0,
            o = "";
          do {
            let i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  `IF${t}`,
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
                ) || "false",
              a = t > 0 ? "else if" : "if";
            (o += `
        ${a} (${i}) {
            ${window.Blockly.JavaScript.javascriptGenerator.statementToCode(
              e,
              `DO${t}`
            )}
        }`),
              t++;
          } while (e.getInput(`IF${t}`));
          return (
            e.getInput("ELSE") &&
              (o += `
        else {
            ${window.Blockly.JavaScript.javascriptGenerator.statementToCode(
              e,
              "ELSE"
            )}
        }`),
            `${o}
`
          );
        }),
        (window.Blockly.Blocks.logic_boolean = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1",
            args0: [
              {
                type: "field_dropdown",
                name: "BOOL",
                options: [
                  [(0, i.NC)("true"), "TRUE"],
                  [(0, i.NC)("false"), "FALSE"],
                ],
              },
            ],
            inputsInline: !0,
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns either True or False"),
            category: window.Blockly.Categories.Logic,
          }),
          meta: () => ({
            display_name: (0, i.NC)("True-False"),
            description: (0, i.NC)(
              "This is a single block that returns a boolean value, either true or false."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.logic_boolean =
          (e) => [
            "TRUE" === e.getFieldValue("BOOL") ? "true" : "false",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.logic_operation = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            args0: [
              { type: "input_value", name: "A" },
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  [(0, i.NC)("and"), "AND"],
                  [(0, i.NC)("or"), "OR"],
                ],
              },
              { type: "input_value", name: "B" },
            ],
            inputsInline: !0,
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Performs selected logic operation"),
            category: window.Blockly.Categories.Logic,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Logic operation"),
            description: (0, i.NC)(
              'This block performs the "AND" or the "OR" logic operation.'
            ),
          }),
          getRequiredValueInputs: () => ({ A: null, B: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.logic_operation =
          (e) => {
            let t, o;
            let i = e.getFieldValue("OP");
            "AND" === i
              ? ((t = "&&"),
                (o =
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_LOGICAL_AND))
              : "OR" === i &&
                ((t = "||"),
                (o =
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_LOGICAL_OR));
            let a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "A",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "false",
              l =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "B",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
                ) || "false";
            return [`${a} ${t} ${l}`, o];
          }),
        (window.Blockly.Blocks.logic_null = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            inputsInline: !0,
            message0: "null",
            output: null,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block assigns a null value to an item or statement."
            ),
            category: window.Blockly.Categories.Logic,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Null"),
            description: (0, i.NC)(
              "This block assigns a null value to an item or statement."
            ),
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.logic_null =
          () => [
            "null",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.logic_ternary = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("test {{ condition }}", { condition: "%1" }),
            message1: (0, i.NC)("if true {{ return_value }}", {
              return_value: "%1",
            }),
            message2: (0, i.NC)("if false {{ return_value }}", {
              return_value: "%1",
            }),
            args0: [{ type: "input_value", name: "IF", check: "Boolean" }],
            args1: [{ type: "input_value", name: "THEN" }],
            args2: [{ type: "input_value", name: "ELSE" }],
            inputsInline: !0,
            output: null,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block tests if a given value is true or false and returns “True” or “False” accordingly."
            ),
            category: window.Blockly.Categories.Logic,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Test value"),
            description: (0, i.NC)(
              "This block tests if a given value is true or false and returns “True” or “False” accordingly."
            ),
          }),
          getRequiredValueInputs: () => ({ IF: null, THEN: null, ELSE: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.logic_ternary =
          (e) => {
            let t =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "IF",
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_CONDITIONAL
                ) || "false",
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "THEN",
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_CONDITIONAL
                ) || "null",
              i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "ELSE",
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_CONDITIONAL
                ) || "null";
            return [
              `(${t} ? ${o} : ${i})`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_CONDITIONAL,
            ];
          }),
        (window.Blockly.Blocks.logic_negate = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("not {{ boolean }}", { boolean: "%1" }),
            args0: [{ type: "input_value", name: "BOOL" }],
            inputsInline: !0,
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Converts a given True or False to the opposite value"
            ),
            category: window.Blockly.Categories.Logic,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Logic negation"),
            description: (0, i.NC)(
              "This block converts the boolean value (true or false) to its opposite."
            ),
          }),
          getRequiredValueInputs: () => ({ BOOL: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.logic_negate = (
          e
        ) => {
          let t =
              window.Blockly.JavaScript.javascriptGenerator.ORDER_LOGICAL_NOT,
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "BOOL",
                t
              ) || "true";
          return [`!${o}`, t];
        }),
        (window.Blockly.Blocks.math_change = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("change {{ variable }} by {{ number }}", {
              variable: "%1",
              number: "%2",
            }),
            args0: [
              {
                type: "field_variable",
                name: "VAR",
                variable: (0, i.NC)("item"),
              },
              { type: "input_value", name: "DELTA", check: "Number" },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)(
              "This block adds the given number to the selected variable"
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Change variable"),
            description: (0, i.NC)(
              "This block adds the given number to the selected variable."
            ),
          }),
          getRequiredValueInputs: () => ({ DELTA: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_change = (
          e
        ) => {
          let t = e.getFieldValue("VAR"),
            o = window.Blockly.JavaScript.variableDB_.getName(
              t,
              window.Blockly.Variables.CATEGORY_NAME
            ),
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "DELTA",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ADDITION
              ) || "0";
          return `${o} = (typeof ${o} === 'number' ? ${o} : 0) + ${i};`;
        }),
        (window.Blockly.Blocks.math_constant = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1",
            args0: [
              {
                type: "field_dropdown",
                name: "CONSTANT",
                options: [
                  ["π", "PI"],
                  ["ℇ", "E"],
                  ["ϕ", "GOLDEN_RATIO"],
                  ["sqrt(2)", "SQRT2"],
                  ["sqrt(\xbd)", "SQRT1_2"],
                  ["∞", "INFINITY"],
                ],
              },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you the selected constant values."
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Mathematical constants"),
            description: (0, i.NC)(
              "This block gives you the selected constant values."
            ),
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_constant =
          (e) => {
            let t, o;
            let i = e.getFieldValue("CONSTANT");
            return (
              "PI" === i
                ? ((t = "Math.PI"),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER))
                : "E" === i
                ? ((t = "Math.E"),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER))
                : "GOLDEN_RATIO" === i
                ? ((t = "(1 + Math.sqrt(5)) / 2"),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator
                      .ORDER_DIVISION))
                : "SQRT2" === i
                ? ((t = "Math.SQRT2"),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER))
                : "SQRT1_2" === i
                ? ((t = "Math.SQRT1_2"),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER))
                : "INFINITY" === i &&
                  ((t = "Infinity"),
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator
                      .ORDER_ATOMIC)),
              [t, o]
            );
          }),
        (window.Blockly.Blocks.math_constrain = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "constrain {{ number }} low {{ low_number }} high {{ high_number }}",
              { number: "%1", low_number: "%2", high_number: "%3" }
            ),
            args0: [
              { type: "input_value", name: "VALUE", check: "Number" },
              { type: "input_value", name: "LOW", check: "Number" },
              { type: "input_value", name: "HIGH", check: "Number" },
            ],
            inputsInline: !0,
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block constrains a given number so that it is within a set range."
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Constrain within a range"),
            description: (0, i.NC)(
              "This block constrains a given number so that it is within a set range."
            ),
          }),
          getRequiredValueInputs: () => ({
            VALUE: null,
            LOW: null,
            HIGH: null,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_constrain =
          (e) => {
            let t =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "VALUE",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                ) || "0",
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "LOW",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                ) || "0",
              i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "HIGH",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                ) || "0";
            return [
              `Math.min(Math.max(${t}, ${o}), ${i})`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ];
          }),
        (window.Blockly.Blocks.math_modulo = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "remainder of {{ number1 }} \xf7 {{ number2 }}",
              { number1: "%1", number2: "%2" }
            ),
            args0: [
              { type: "input_value", name: "DIVIDEND", check: "Number" },
              { type: "input_value", name: "DIVISOR", check: "Number" },
            ],
            inputsInline: !0,
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Returns the remainder after a division"),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Remainder after division"),
            description: (0, i.NC)(
              "Returns the remainder after the division of the given numbers."
            ),
          }),
          getRequiredValueInputs: () => ({ DIVIDEND: null, DIVISOR: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_modulo = (
          e
        ) => {
          let t =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "DIVIDEND",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_MODULUS
              ) || "0",
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "DIVISOR",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_MODULUS
              ) || "0";
          return [
            `${t} % ${o}`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_MODULUS,
          ];
        }),
        (window.Blockly.Blocks.math_number = {
          init() {
            this.jsonInit(this.definition()),
              this.getField("NUM").setValidator((e) => this.numberValidator(e));
          },
          definition: () => ({
            message0: "%1",
            args0: [{ type: "field_number", name: "NUM", value: 0 }],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Please use `.` as a decimal separator for fractional numbers."
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Number"),
            description: (0, i.NC)(
              "Enter an integer or fractional number into this block. Please use `.` as a decimal separator for fractional numbers."
            ),
          }),
          numberValidator(e) {
            if (
              !/^-?([0][.]|[0-9]+[.])?([0]|[1-9]){1,}$/.test(e) ||
              !(e < Number.MAX_SAFE_INTEGER)
            )
              return null;
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_number = (
          e
        ) => [
          e.getFieldValue("NUM"),
          window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
        ]),
        (window.Blockly.Blocks.math_number_positive = {
          init: window.Blockly.Blocks.math_number.init,
          definition: window.Blockly.Blocks.math_number.definition,
          meta: () => ({
            display_name: (0, i.NC)("Math Number Positive"),
            description: (0, i.NC)("Math Number Description"),
          }),
          numberValidator(e) {
            if (
              !/^([0][.]|[0-9]+[.])?([0]|[1-9]){1,}$/.test(e) ||
              !(e < Number.MAX_SAFE_INTEGER)
            )
              return null;
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_number_positive =
          (e) =>
            window.Blockly.JavaScript.javascriptGenerator.forBlock.math_number(
              e
            )),
        (window.Blockly.Blocks.math_number_property = {
          init() {
            this.jsonInit(this.definition()),
              this.setOnChange((e) => {
                if ("PROPERTY" === e.name) {
                  let e = "DIVISIBLE_BY" === this.getFieldValue("PROPERTY");
                  this.updateShape(e);
                }
              });
          },
          definition: () => ({
            message0: (0, i.NC)("{{ number }} is {{ type }}", {
              number: "%1",
              type: "%2",
            }),
            args0: [
              { type: "input_value", name: "NUMBER_TO_CHECK" },
              {
                type: "field_dropdown",
                name: "PROPERTY",
                options: [
                  [(0, i.NC)("even"), "EVEN"],
                  [(0, i.NC)("odd"), "ODD"],
                  [(0, i.NC)("prime"), "PRIME"],
                  [(0, i.NC)("whole"), "WHOLE"],
                  [(0, i.NC)("positive"), "POSITIVE"],
                  [(0, i.NC)("negative"), "NEGATIVE"],
                  [(0, i.NC)("divisible by"), "DIVISIBLE_BY"],
                ],
              },
            ],
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            toolip: (0, i.NC)(
              "This block tests a given number according to the selection"
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Test a number"),
            description: (0, i.NC)(
              "This block tests a given number according to the selection and it returns a value of “True” or “False”. Available options: Even, Odd, Prime, Whole, Positive, Negative, Divisible"
            ),
          }),
          domToMutation(e) {
            let t = "true" === e.getAttribute("divisor_input");
            this.updateShape(t);
          },
          mutationToDom() {
            let e = document.createElement("mutation"),
              t = "DIVISIBLE_BY" === this.getFieldValue("PROPERTY");
            return e.setAttribute("divisor_input", t), e;
          },
          updateShape(e) {
            e &&
              (this.getInput("DIVISOR")
                ? this.removeInput("DIVISOR")
                : (this.appendValueInput("DIVISOR").setCheck("Number"),
                  this.initSvg(),
                  this.renderEfficiently()));
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          getRequiredValueInputs: () => ({ NUMBER_TO_CHECK: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_number_property =
          (e) => {
            let t;
            let o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "NUMBER_TO_CHECK",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_MODULUS
                ) || "0",
              i = e.getFieldValue("PROPERTY");
            if ("PRIME" === i) {
              let e =
                window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                  "mathIsPrime",
                  [
                    `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(n) {
                // https://en.wikipedia.org/wiki/Primality_test#Naive_methods
                if (n == 2 || n == 3) {
                    return true;
                }

                // False if n is NaN, negative, is 1, or not whole.
                // And false if n is divisible by 2 or 3.
                if (isNaN(n) || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {
                    return false;
                }

                // Check all the numbers of form 6k +/- 1, up to sqrt(n).
                for (var x  = 6; x <= Math.sqrt(n) + 1; x += 6) {
                    if (n % (x - 1) == 0 || n % (x + 1) == 0) {
                        return false;
                    }
                }
                return true;
            }`,
                  ]
                );
              return [
                (t = `${e}(${o})`),
                window.Blockly.JavaScript.javascriptGenerator
                  .ORDER_FUNCTION_CALL,
              ];
            }
            if ("EVEN" === i) t = `${o} % 2 === 0`;
            else if ("ODD" === i) t = `${o} % 2 === 1`;
            else if ("WHOLE" === i) t = `${o} % 1 === 0`;
            else if ("POSITIVE" === i) t = `${o} > 0`;
            else if ("NEGATIVE" === i) t = `${o} < 0`;
            else if ("DIVISIBLE_BY" === i) {
              let i =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "DIVISOR",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_MODULUS
                ) || "0";
              t = `${o} % ${i} == 0`;
            }
            return [
              t,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_EQUALITY,
            ];
          }),
        (window.Blockly.Blocks.math_on_list = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("{{ calculation }} of list {{ input_list }}", {
              calculation: "%1",
              input_list: "%2",
            }),
            args0: [
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  [(0, i.NC)("sum"), "SUM"],
                  [(0, i.NC)("min"), "MIN"],
                  [(0, i.NC)("max"), "MAX"],
                  [(0, i.NC)("average"), "AVERAGE"],
                  [(0, i.NC)("median"), "MEDIAN"],
                  [(0, i.NC)("mode"), "MODE"],
                  [(0, i.NC)("antimode"), "ANTIMODE"],
                  [(0, i.NC)("standard deviation"), "STD_DEV"],
                  [(0, i.NC)("random item"), "RANDOM"],
                ],
              },
              { type: "input_value", name: "LIST" },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Aggregate operations"),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Aggregate operations"),
            description: (0, i.NC)(
              "This block performs the following operations on a given list: sum, minimum, maximum, average, median, mode, antimode, standard deviation, random item."
            ),
          }),
          getRequiredValueInputs() {
            let e = [
              "variables_get",
              "lists_getSublist",
              "ohlc_values",
              "lists_split",
              "ohlc",
              "ticks",
              "lists_repeat",
              "lastDigitList",
              "ohlc_values_in_list",
              "procedures_callreturn",
            ];
            return {
              LIST: () => {
                var t;
                return !e.includes(
                  null === (t = this.childBlocks_[0]) || void 0 === t
                    ? void 0
                    : t.type
                );
              },
            };
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_on_list = (
          e
        ) => {
          let t, o;
          let i = e.getFieldValue("OP");
          if ("SUM" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathMean",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(myList) {
                var final_list = [];
                return recursiveList(myList, final_list).reduce(function(x, y) {
                    return x + y;
                },0);
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("MIN" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathMean",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(myList) {
                var final_list = [];
                return Math.min.apply(null, (recursiveList(myList, final_list) || [0]));
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("MAX" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathMean",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(myList) {
                var final_list = [];
                return Math.max.apply(null, (recursiveList(myList, final_list) || [0]));
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("AVERAGE" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathMean",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(myList) {
                var final_list = [];
                return recursiveList(myList, final_list).reduce(function(x, y) {
                    return x + y;
                }, 0) / myList.length;
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("MEDIAN" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathMedian",
                [
                  `
            Array.prototype.swap = function (x,y) {
                var b = this[x];
                this[x] = this[y];
                this[y] = b;
                return this;
            }

            function partition(arr, start, end){
                var pivotValue = arr[end];
                var pivotIndex = start;
                for (var i = start; i < end; i++) {
                    if (arr[i] < pivotValue) {
                    arr.swap(pivotIndex, i);
                    pivotIndex++;
                    }
                }
                arr.swap(end, pivotIndex);
                return pivotIndex;
            };

            function quickSort(arr) {
                var stack = [];
                stack.push(0);
                stack.push(arr.length - 1);

                while(stack[stack.length - 1] >= 0){
                    end = stack.pop();
                    start = stack.pop();
                    pivotIndex = partition(arr, start, end);
                    if (pivotIndex - 1 > start){
                        stack.push(start);
                        stack.push(pivotIndex - 1);
                    }
                    if (pivotIndex + 1 < end){
                        stack.push(pivotIndex + 1);
                        stack.push(end);
                    }
                }

            }

            function calculateMedian(final_list){
                quickSort(final_list);

                if (final_list.length % 2 == 0) {
                    return (final_list[final_list.length / 2 - 1] + final_list[final_list.length / 2]) / 2;
                }
                return final_list[(final_list.length - 1) / 2];
            }

            function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(myList) {
                var final_list = [];
                return calculateMedian(recursiveList(myList, final_list));
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("MODE" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathModes",
                [
                  `
            function calculateMathMode(values){
                var modes = [];
                var counts = [];
                var maxCount = 0;

                for (var i = 0; i < values.length; i++) {
                    var value = values[i];
                    var found = false;
                    var thisCount;

                    for (var j = 0; j < counts.length; j++) {
                        if (counts[j][0] === value) {
                            thisCount = ++counts[j][1];
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        counts.push([value, 1]);
                        thisCount = 1;
                    }
                    maxCount = Math.max(thisCount, maxCount);
                }

                for (var j = 0; j < counts.length; j++) {
                    if (counts[j][1] == maxCount) {
                        modes.push(counts[j][0]);
                    }
                }

                return modes;
            }

            function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(list) {
                var final_list = [];
                return calculateMathMode(recursiveList(list, final_list));
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("ANTIMODE" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathAntiMode",
                [
                  `
            function calculateMathAntiMode(values){
                var antiMode = [];
                var counts = [];
                var minCount = 1;
                var countArray = [];

                for (var i = 0; i < values.length; i++) {
                    var value = values[i];
                    var found = false;
                    var thisCount;

                    for (var j = 0; j < counts.length; j++) {
                        if (counts[j][0] === value) {
                            thisCount = ++counts[j][1];
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        counts.push([value, 1]);
                        thisCount = 1;
                    }
                }

                 minCount = Math.min.apply(null, counts.map(function(element) {
                     return element[1];
                 }));

                 for (var j = 0; j < counts.length; j++) {
                    if (counts[j][1] == minCount) {
                        antiMode.push(counts[j][0]);
                    }
                }

                return antiMode;
            }

            function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(list) {
                var final_list = [];
                return calculateMathAntiMode(recursiveList(list, final_list));
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("STD_DEV" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathStandardDeviation",
                [
                  `
            function calculateMathStandardDeviation(numbers){
                var n = numbers.length;
                if (!n) {
                    return null;
                }

                var mean = numbers.reduce(function(x, y) {
                    return x + y;
                }, 0) / n;

                var variance = 0;
                for (var j = 0; j < n; j++) {
                    variance += Math.pow(numbers[j] - mean, 2);
                }
                variance = variance / n;
                return Math.sqrt(variance);
            }

            function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(list) {
                var final_list = [];
                return calculateMathStandardDeviation(recursiveList(list, final_list));
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          } else if ("RANDOM" === i) {
            let i =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "mathRandomList",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(list) {
                var final_list = [];
                var final_list = recursiveList(list, final_list);
                var x = Math.floor(Math.random() * final_list.length);
                return final_list[x];
            }`,
                ]
              );
            (o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "LIST",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "[]"),
              (t = `${i}((${o} || [0]))`);
          }
          return [
            t,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        }),
        (window.Blockly.Blocks.math_random_float = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("random fraction"),
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you a random fraction between 0.0 to 1.0"
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Random fraction number"),
            description: (0, i.NC)(
              "This block gives you a random fraction between 0.0 to 1.0."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_random_float =
          () => [
            "Math.random()",
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ]),
        (window.Blockly.Blocks.math_random_int = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "random integer from {{ start_number }} to {{ end_number }}",
              { start_number: "%1", end_number: "%2" }
            ),
            args0: [
              { type: "input_value", name: "FROM", check: "Number" },
              { type: "input_value", name: "TO", check: "Number" },
            ],
            inputsInline: !0,
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block gives you a random number from within a set range"
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Random integer"),
            description: (0, i.NC)(
              "This block gives you a random number from within a set range."
            ),
          }),
          getRequiredValueInputs: () => ({ FROM: null, TO: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_random_int =
          (e) => {
            let t =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "FROM",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                ) || "0",
              o =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TO",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA
                ) || "0",
              i =
                window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                  "mathRandomInt",
                  [
                    `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(a, b) {
            if (a > b) {
                // Swap a and b to ensure a is smaller.
                var c = a;
                a = b;
                b = c;
            }
            return Math.floor(Math.random() * (b - a + 1) + a);
        }`,
                  ]
                );
            return [
              `${i}(${t}, ${o})`,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ];
          }),
        (window.Blockly.Blocks.math_round = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2",
            args0: [
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  ["round", "ROUND"],
                  ["round up", "ROUNDUP"],
                  ["round down", "ROUNDDOWN"],
                ],
              },
              { type: "input_value", name: "NUM" },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Rounds a given number to an integer"),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Rounding operation"),
            description: (0, i.NC)(
              "This block rounds a given number according to the selection: round, round up, round down."
            ),
          }),
          getRequiredValueInputs: () => ({ NUM: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_round = (
          e
        ) => {
          let t;
          let o = e.getFieldValue("OP"),
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "NUM",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
              ) || "0";
          return (
            "ROUND" === o
              ? (t = `Math.round(${i})`)
              : "ROUNDUP" === o
              ? (t = `Math.ceil(${i})`)
              : "ROUNDDOWN" === o && (t = `Math.floor(${i})`),
            [
              t,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ]
          );
        }),
        (window.Blockly.Blocks.math_arithmetic = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2 %3",
            args0: [
              { type: "input_value", name: "A", check: "Number" },
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  ["+", "ADD"],
                  ["-", "MINUS"],
                  ["*", "MULTIPLY"],
                  ["/", "DIVIDE"],
                  ["^", "POWER"],
                ],
              },
              { type: "input_value", name: "B", check: "Number" },
            ],
            output: "Number",
            inputsInline: !0,
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "This block performs arithmetic operations between two numbers."
            ),
            category: window.Blockly.Categories.Mathematical,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Arithmetical operations"),
            description: (0, i.NC)(
              "This block performs arithmetic operations between two numbers."
            ),
          }),
          getRequiredValueInputs: () => ({ A: null, B: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_arithmetic =
          (e) => {
            let t;
            let o = {
                ADD: [
                  "+",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_ADDITION,
                ],
                MINUS: [
                  "-",
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_SUBTRACTION,
                ],
                MULTIPLY: [
                  "*",
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_MULTIPLICATION,
                ],
                DIVIDE: [
                  "/",
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_DIVISION,
                ],
                POWER: [
                  null,
                  window.Blockly.JavaScript.javascriptGenerator.ORDER_COMMA,
                ],
              }[e.getFieldValue("OP")],
              i = o[0],
              a = o[1],
              l =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "A",
                  a
                ) || "0",
              n =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "B",
                  a
                ) || "0";
            return i
              ? [`${l} ${i} ${n}`, a]
              : [
                  `Math.pow(${l}, ${n})`,
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_FUNCTION_CALL,
                ];
          }),
        (window.Blockly.Blocks.math_single = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2",
            args0: [
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  [(0, i.NC)("square root"), "ROOT"],
                  [(0, i.NC)("absolute"), "ABS"],
                  ["-", "NEG"],
                  ["ln", "LN"],
                  ["log10", "LOG10"],
                  ["e^", "EXP"],
                  ["10^", "POW10"],
                ],
              },
              { type: "input_value", name: "NUM" },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Operations on a given number"),
            category: window.Blockly.Categories.Mathematical,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Operations on a given number"),
            description: (0, i.NC)(
              "This block performs the selected operations to a given number."
            ),
          }),
          getRequiredValueInputs: () => ({ NUM: null }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_single = (
          e
        ) => {
          let t, o;
          let i = e.getFieldValue("OP");
          return "NEG" === i
            ? ("-" ===
                (o =
                  window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "NUM",
                    window.Blockly.JavaScript.javascriptGenerator
                      .ORDER_UNARY_NEGATION
                  ) || "0")[0] && (o = ` ${o}`),
              [
                (t = `-${o}`),
                window.Blockly.JavaScript.javascriptGenerator
                  .ORDER_UNARY_NEGATION,
              ])
            : ((o = ["SIN", "COS", "TAN"].includes(i)
                ? window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "NUM",
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_DIVISION
                  ) || "0"
                : window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "NUM",
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
                  ) || "0"),
              "ABS" === i
                ? (t = `Math.abs(${o})`)
                : "ROOT" === i
                ? (t = `Math.sqrt(${o})`)
                : "LN" === i
                ? (t = `Math.log(${o})`)
                : "EXP" === i
                ? (t = `Math.pow(Math.E, ${o})`)
                : "POW10" === i
                ? (t = `Math.pow(10, ${o})`)
                : "ROUND" === i
                ? (t = `Math.round(${o})`)
                : "ROUNDUP" === i
                ? (t = `Math.ceil(${o})`)
                : "ROUNDDOWN" === i
                ? (t = `Math.floor(${o})`)
                : "SIN" === i
                ? (t = `Math.sin(${o} / 180 * Math.PI)`)
                : "COS" === i
                ? (t = `Math.cos(${o} / 180 * Math.PI)`)
                : "TAN" === i && (t = `Math.tan(${o} / 180 * Math.PI)`),
              t)
            ? [
                t,
                window.Blockly.JavaScript.javascriptGenerator
                  .ORDER_FUNCTION_CALL,
              ]
            : ("LOG10" === i
                ? (t = `Math.log(${o}) / Math.log(10)`)
                : "ASIN" === i
                ? (t = `Math.asin(${o}) / Math.PI * 180`)
                : "ACOS" === i
                ? (t = `Math.acos(${o}) / Math.PI * 180`)
                : "ATAN" === i && (t = `Math.atan(${o}) / Math.PI * 180`),
              [
                t,
                window.Blockly.JavaScript.javascriptGenerator.ORDER_DIVISION,
              ]);
        }),
        (window.Blockly.Blocks.math_trig = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1 %2",
            args0: [
              {
                type: "field_dropdown",
                name: "OP",
                options: [
                  ["sin", "SIN"],
                  ["cos", "COS"],
                  ["tan", "TAN"],
                  ["asin", "ASIN"],
                  ["acos", "ACOS"],
                  ["atan", "ATAN"],
                ],
              },
              { type: "input_value", name: "NUM", check: "Number" },
            ],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Trigonometric functions"),
            category: window.Blockly.Categories.Mathematical,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Trigonometric functions"),
            description: (0, i.NC)(
              "This block performs trigonometric functions."
            ),
          }),
          getRequiredValueInputs: () => ({ NUM: null }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.math_trig =
          window.Blockly.JavaScript.javascriptGenerator.forBlock.math_single),
        (window.Blockly.Blocks.text = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: "%1",
            args0: [{ type: "field_input", name: "TEXT" }],
            inputsInline: !0,
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Enter some text here"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Text"),
            description: (0, i.NC)("A  block that can contain text."),
          }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text = (e) => [
          window.Blockly.JavaScript.javascriptGenerator.quote_(
            e.getFieldValue("TEXT")
          ),
          window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
        ]),
        (window.Blockly.Blocks.text_join = {
          protected_statements: ["STACK"],
          allowed_children: ["text_statement"],
          init() {
            let e = new window.Blockly.FieldImage(
              l.M8,
              25,
              25,
              "",
              this.onIconClick.bind(this)
            );
            this.jsonInit(this.definition()),
              this.appendDummyInput("ADD_ICON").appendField(e),
              this.moveInputBefore("ADD_ICON", "STACK");
          },
          definition: () => ({
            message0: (0, i.NC)("set {{ variable }} to create text with", {
              variable: "%1",
            }),
            message1: "%1",
            args0: [
              {
                type: "field_variable",
                name: "VARIABLE",
                variable: (0, i.NC)("text"),
              },
            ],
            args1: [{ type: "input_statement", name: "STACK" }],
            inputsInline: !0,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Text join"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Text join"),
            description: (0, i.NC)(
              "Creates a single text string from combining the text value of each attached item, without spaces in between. The number of items can be added accordingly."
            ),
          }),
          onIconClick() {
            !this.workspace.options.readOnly &&
              !window.Blockly.derivWorkspace.isFlyoutVisible &&
              (0, a.UR)(!1, () => {
                let e = this.workspace.newBlock("text_statement");
                (e.required_parent_id = this.id),
                  e.setMovable(!0),
                  e.initSvg(),
                  null == e || e.renderEfficiently();
                let t = this.workspace.newBlock("text");
                t.setShadow(!0),
                  t.setFieldValue("", "TEXT"),
                  t.initSvg(),
                  null == t || t.renderEfficiently(),
                  e.getInput("TEXT").connection.connect(t.outputConnection),
                  this.getLastConnectionInStatement("STACK").connect(
                    e.previousConnection
                  );
              });
          },
          onchange: window.Blockly.Blocks.lists_create_with.onchange,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_join = (
          e
        ) => {
          let t = window.Blockly.JavaScript.variableDB_.getName(
              e.getFieldValue("VARIABLE"),
              window.Blockly.Variables.CATEGORY_NAME
            ),
            o = e.getBlocksInStatement("STACK").map((e) => {
              let t =
                window.Blockly.JavaScript.javascriptGenerator.forBlock[e.type](
                  e
                );
              return Array.isArray(t) ? t[0] : t;
            });
          return `${t} = [${o}].join(" ");
`;
        }),
        (window.Blockly.Blocks.text_statement = {
          required_parent_type: "text_join",
          init() {
            this.required_parent_id = "";
            let e = new window.Blockly.FieldImage(
              l.fK,
              25,
              25,
              "",
              this.onIconClick.bind(this)
            );
            this.jsonInit(this.definition()),
              this.appendDummyInput("REMOVE_ICON").appendField(e);
          },
          definition: () => ({
            message0: "%1",
            args0: [{ type: "input_value", name: "TEXT" }],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Text Statement"),
            description: "",
          }),
          onchange(e) {
            if (
              !this.workspace ||
              window.Blockly.derivWorkspace.isFlyoutVisible ||
              this.workspace.isDragging()
            )
              return;
            let t = this.getSurroundParent();
            if (
              (e.type !== window.Blockly.Events.BLOCK_CREATE ||
                (this.setMovable(!0),
                this.required_parent_id ||
                  (null == t ? void 0 : t.type) !== this.required_parent_type ||
                  (this.required_parent_id = t.id)),
              e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart)
            ) {
              let o = window.Blockly.getMainWorkspace().getBlockById(e.blockId);
              if (
                this.required_parent_id &&
                (!t || t.id !== this.required_parent_id)
              ) {
                let e = window.Blockly.getMainWorkspace().getBlockById(
                  this.required_parent_id
                );
                if (e) {
                  if (e.getInputTargetBlock("STACK")) {
                    let t = e.getLastConnectionInStatement("STACK");
                    (0, a.$9)(() => {
                      t.connect(this.previousConnection);
                    });
                  } else
                    (0, a.$9)(() => {
                      e.getInput("STACK").connection.connect(
                        o.previousConnection
                      );
                    });
                }
              }
            }
          },
          onIconClick: window.Blockly.Blocks.lists_statement.onIconClick,
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_statement =
          (e) => [
            `String(${window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "TEXT",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC
            )})`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
          ]),
        (window.Blockly.Blocks.text_append = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "to {{ variable }} append text {{ input_text }}",
              { variable: "%1", input_text: "%2" }
            ),
            args0: [
              {
                type: "field_variable",
                name: "VAR",
                variable: (0, i.NC)("text"),
              },
              { type: "input_value", name: "TEXT" },
            ],
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Appends a given text to a variable"),
            category: window.Blockly.Categories.Text,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Text Append"),
            description: (0, i.NC)("Appends a given text to a variable."),
          }),
          getRequiredValueInputs: () => ({ TEXT: a.cM }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_append = (
          e
        ) => {
          let t = window.Blockly.JavaScript.variableDB_.getName(
              e.getFieldValue("VAR"),
              window.Blockly.Variables.CATEGORY_NAME
            ),
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "TEXT",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "''";
          return `${t} += ${
            /^\s*'([^']|\\')*'\s*$/.test(o) ? o : `String(${o})`
          };
`;
        }),
        (window.Blockly.Blocks.text_length = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("length of {{ input_text }}", {
              input_text: "%1",
            }),
            args0: [{ type: "input_value", name: "VALUE" }],
            output: "Number",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Text String Length"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Text String Length"),
            description: (0, i.NC)(
              "Returns the number of characters of a given string of text, including numbers, spaces, punctuation marks, and symbols."
            ),
          }),
          getRequiredValueInputs: () => ({ VALUE: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_length = (
          e
        ) => {
          let t =
            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "VALUE",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL
            ) || "''";
          return [
            `${t}.length`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER,
          ];
        }),
        (window.Blockly.Blocks.text_isEmpty = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("text {{ input_text }} is empty", {
              input_text: "%1",
            }),
            args0: [{ type: "input_value", name: "VALUE", check: ["String"] }],
            output: "Boolean",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Tests if a given text string is empty"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Text Is empty"),
            description: (0, i.NC)(
              "Tests whether a string of text is empty. Returns a boolean value (true or false)."
            ),
          }),
          getRequiredValueInputs: () => ({ VALUE: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_isEmpty = (
          e
        ) => {
          let t =
            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "VALUE",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
            ) || "''";
          return [
            -1 !== e.workspace.getAllVariables().findIndex((e) => e.name === t)
              ? `!${t} || !${t}.length`
              : `!${t}.length`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_LOGICAL_NOT,
          ];
        }),
        (window.Blockly.Blocks.text_indexOf = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "in text {{ input_text1 }} find {{ first_or_last }} occurence of text {{ input_text2 }}",
              { input_text1: "%1", first_or_last: "%2", input_text2: "%3" }
            ),
            args0: [
              { type: "input_value", name: "VALUE" },
              {
                type: "field_dropdown",
                name: "END",
                options: [
                  [(0, i.NC)("first"), "FIRST"],
                  [(0, i.NC)("last"), "LAST"],
                ],
              },
              { type: "input_value", name: "FIND" },
            ],
            inputsInline: !0,
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Search for a given string"),
            cateogry: window.Blockly.Categories.Text,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Search for string"),
            description: (0, i.NC)(
              "Searches through a string of text for a specific occurrence of a given character or word, and returns the position."
            ),
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          getRequiredValueInputs: () => ({ VALUE: a.cM, FIND: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_indexOf = (
          e
        ) => {
          let t =
              "FIRST" === e.getFieldValue("END") ? "indexOf" : "lastIndexOf",
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "FIND",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
              ) || "''",
            i =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "VALUE",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
              ) || "''",
            a = `${i}.${t}(${o})`;
          return e.workspace.options.oneBasedIndex
            ? [
                `${a} + 1`,
                window.Blockly.JavaScript.javascriptGenerator.ORDER_ADDITION,
              ]
            : [
                a,
                window.Blockly.JavaScript.javascriptGenerator
                  .ORDER_FUNCTION_CALL,
              ];
        }),
        (window.Blockly.Blocks.text_charAt = {
          init() {
            this.jsonInit(this.definition()),
              this.getField("WHERE").setValidator((e) => {
                let t = ["FROM_START", "FROM_END"].includes(e);
                if (t !== this.isAt)
                  return this.updateAt(t), this.setFieldValue(e, "WHERE"), null;
              }),
              this.updateAt(!0);
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          definition: () => ({
            message0: (0, i.NC)("in text %1 get %2"),
            args0: [
              { type: "input_value", name: "VALUE" },
              {
                type: "field_dropdown",
                name: "WHERE",
                options: [
                  [(0, i.NC)("letter #"), "FROM_START"],
                  [(0, i.NC)("letter # from end"), "FROM_END"],
                  [(0, i.NC)("first letter"), "FIRST"],
                  [(0, i.NC)("last letter"), "LAST"],
                  [(0, i.NC)("random letter"), "RANDOM"],
                ],
              },
            ],
            inputsInline: !0,
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)(
              "Returns a specific character from a given string"
            ),
            category: window.Blockly.Categories.Text,
          }),
          meta: () => ({
            display_name: (0, i.NC)("Get character"),
            description: (0, i.NC)(
              "Returns the specific character from a given string of text according to the selected option. "
            ),
          }),
          mutationToDom() {
            let e = document.createElement("mutation");
            return e.setAttribute("at", !!this.isAt), e;
          },
          domToMutation(e) {
            let t = "false" !== e.getAttribute("at");
            this.updateAt(t);
          },
          updateAt(e) {
            this.removeInput("AT", !0),
              e && this.appendValueInput("AT").setCheck("Number"),
              (this.isAt = e),
              this.initSvg(),
              this.renderEfficiently();
          },
          getRequiredValueInputs: () => ({ VALUE: a.cM, AT: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_charAt = (
          e
        ) => {
          let t;
          let o = e.getFieldValue("WHERE") || "FROM_START",
            i =
              "RANDOM" === o
                ? window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
                : window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER,
            a =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "VALUE",
                i
              ) || "''";
          if ("FROM_START" === o) {
            let o = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
              e,
              "AT"
            );
            t = `${a}.charAt(${o})`;
          } else if ("FROM_END" === o) {
            let o = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
              e,
              "AT",
              1,
              !0
            );
            t = `${a}.slice(${o}).charAt(0)`;
          } else if ("FIRST" === o) t = `${a}.charAt(0)`;
          else if ("LAST" === o) t = `${a}.slice(-1)`;
          else if ("RANDOM" === o) {
            let e =
              window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                "textRandomLetter",
                [
                  `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(text) {
                var x = Math.floor(Math.random() * text.length);
                return text[x];
            }`,
                ]
              );
            t = `${e}(${a})`;
          }
          return [
            t,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        }),
        (window.Blockly.Blocks.text_getSubstring = {
          init() {
            (this.WHERE_OPTIONS_1 = [
              [(0, i.NC)("letter #"), "FROM_START"],
              [(0, i.NC)("letter # from end"), "FROM_END"],
              [(0, i.NC)("first"), "FIRST"],
            ]),
              (this.WHERE_OPTIONS_2 = [
                [(0, i.NC)("letter #"), "FROM_START"],
                [(0, i.NC)("letter # from end"), "FROM_END"],
                [(0, i.NC)("last"), "LAST"],
              ]),
              this.jsonInit(this.definition()),
              this.updateAt(1, !0),
              this.updateAt(2, !0);
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          definition() {
            return {
              message0: (0, i.NC)(
                "in text {{ input_text }} get substring from {{ position1 }} {{ index1 }} to {{ position2 }} {{ index2 }}",
                {
                  input_text: "%1",
                  position1: "%2",
                  index1: "%3",
                  position2: "%4",
                  index2: "%5",
                }
              ),
              args0: [
                { type: "input_value", name: "STRING" },
                {
                  type: "field_dropdown",
                  name: "WHERE1",
                  options: this.WHERE_OPTIONS_1,
                },
                { type: "input_dummy", name: "AT1" },
                {
                  type: "field_dropdown",
                  name: "WHERE2",
                  options: this.WHERE_OPTIONS_2,
                },
                { type: "input_dummy", name: "AT2" },
              ],
              inputsInline: !0,
              output: "String",
              outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
              colour: window.Blockly.Colours.Base.colour,
              colourSecondary: window.Blockly.Colours.Base.colourSecondary,
              colourTertiary: window.Blockly.Colours.Base.colourTertiary,
              tooltip: (0, i.NC)(
                "Returns a specific portion of a given string of text."
              ),
              category: window.Blockly.Categories.Text,
            };
          },
          meta: () => ({
            display_name: (0, i.NC)("Get substring"),
            description: (0, i.NC)(
              "Returns a specific portion of a given string of text."
            ),
          }),
          mutationToDom() {
            let e = document.createElement("mutation"),
              t = this.getInput("AT1").type === window.Blockly.INPUT_VALUE,
              o = this.getInput("AT2").type === window.Blockly.INPUT_VALUE;
            return e.setAttribute("at1", t), e.setAttribute("at2", o), e;
          },
          domToMutation(e) {
            let t = "true" === e.getAttribute("at1"),
              o = "true" === e.getAttribute("at2");
            this.updateAt(1, t), this.updateAt(2, o);
          },
          updateAt(e, t) {
            let o;
            let i = this.getInput(`AT${e}`);
            i &&
              (i.fieldRow.some((e) => {
                e instanceof window.Blockly.FieldLabel && (o = e.text_);
              }),
              this.removeInput(`AT${e}`));
            let a = t
              ? this.appendValueInput(`AT${e}`).setCheck("Number")
              : this.appendDummyInput(`AT${e}`);
            o && a.insertFieldAt(0, new window.Blockly.FieldLabel(o));
            let l = new window.Blockly.FieldDropdown(
              this[`WHERE_OPTIONS_${e}`],
              (o) => {
                let i = ["FROM_START", "FROM_END"].includes(o);
                if (i !== t)
                  return (
                    this.updateAt(e, i),
                    this.setFieldValue(o, `WHERE${e}`),
                    null
                  );
              }
            );
            this.getInput(`AT${e}`).appendField(l, `WHERE${e}`),
              1 === e && this.moveInputBefore("AT1", "AT2"),
              this.initSvg(),
              this.renderEfficiently();
          },
          getRequiredValueInputs() {
            let e = (e) => {
              var t;
              return (
                (null === (t = this.getInput(e)) || void 0 === t
                  ? void 0
                  : t.type) === window.Blockly.INPUT_VALUE
              );
            };
            return {
              STRING: a.cM,
              ...(e("AT1") ? { AT1: a.cM } : {}),
              ...(e("AT2") ? { AT2: a.cM } : {}),
            };
          },
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_getSubstring =
          (e) => {
            let t, o, i;
            let a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "STRING",
                  window.Blockly.JavaScript.javascriptGenerator
                    .ORDER_FUNCTION_CALL
                ) || "''",
              l = e.getFieldValue("WHERE1"),
              n = e.getFieldValue("WHERE2");
            if ("FIRST" === l && "LAST" === n) i = a;
            else if (
              a.match(/^'?\w+'?$/) ||
              ("FROM_END" !== l &&
                "LAST" !== l &&
                "FROM_END" !== n &&
                "LAST" !== n)
            ) {
              switch (l) {
                case "FROM_START":
                  t = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                    e,
                    "AT1"
                  );
                  break;
                case "FROM_END":
                  (t =
                    window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                      e,
                      "AT1",
                      1,
                      !1,
                      window.Blockly.JavaScript.javascriptGenerator
                        .ORDER_SUBTRACTION
                    )),
                    (t = `${a}.length - ${t}`);
                  break;
                case "FIRST":
                  t = "0";
              }
              switch (n) {
                case "FROM_START":
                  o = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                    e,
                    "AT2",
                    1
                  );
                  break;
                case "FROM_END":
                  (o =
                    window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                      e,
                      "AT2",
                      0,
                      !1,
                      window.Blockly.JavaScript.javascriptGenerator
                        .ORDER_SUBTRACTION
                    )),
                    (o = `${a}.length - ${o}`);
                  break;
                case "LAST":
                  o = `${a}.length`;
              }
              i = `${a}.slice(${t}, ${o})`;
            } else {
              (t = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                e,
                "AT1"
              )),
                (o = window.Blockly.JavaScript.javascriptGenerator.getAdjusted(
                  e,
                  "AT2"
                ));
              let r = (e, t, o) =>
                  "FIRST" === t
                    ? "0"
                    : "FROM_END" === t
                    ? `${e}.length - 1 - ${o}`
                    : "LAST" === t
                    ? `${e}.length - 1`
                    : o,
                s = {
                  FIRST: "First",
                  LAST: "Last",
                  FROM_START: "FromStart",
                  FROM_END: "FromEnd",
                },
                c =
                  window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                    `subsequence${s[l]}${s[n]}`,
                    [
                      `function ${
                        window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_
                      }(
                    sequence
                    ${"FROM_END" === l || "FROM_START" === l ? ", at1" : ""}
                    ${"FROM_END" === n || "FROM_START" === n ? ", at2" : ""}
                ) {
                    var start = ${r("sequence", l, "at1")};
                    var end   = ${r("sequence", n, "at2")} + 1;
                    
                    return sequence.slice(start, end);
                }`,
                    ]
                  );
              i = `${c}(
            ${a}
            ${"FROM_END" === l || "FROM_START" === l ? `, ${t}` : ""}
            ${"FROM_END" === n || "FROM_START" === n ? `, ${o}` : ""}
        )`;
            }
            return [
              i,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ];
          }),
        (window.Blockly.Blocks.text_changeCase = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "Transform {{ input_text }} to {{ transform_type }}",
              { input_text: "%1", transform_type: "%2" }
            ),
            args0: [
              { type: "input_value", name: "TEXT" },
              {
                type: "field_dropdown",
                name: "CASE",
                options: [
                  [(0, i.NC)("UPPER CASE"), "UPPERCASE"],
                  [(0, i.NC)("lower case"), "LOWERCASE"],
                  [(0, i.NC)("Title Case"), "TITLECASE"],
                ],
              },
            ],
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Changes text case accordingly"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Change text case"),
            description: (0, i.NC)(
              "Changes the capitalisation of a string of text to Upper case, Lower case, Title case."
            ),
          }),
          getRequiredValueInputs: () => ({ TEXT: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_changeCase =
          (e) => {
            let t;
            let o = {
                UPPERCASE: ".toUpperCase()",
                LOWERCASE: ".toLowerCase()",
                TITLECASE: null,
              }[e.getFieldValue("CASE")],
              i = o
                ? window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
                : window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE,
              a =
                window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                  e,
                  "TEXT",
                  i
                ) || "''";
            if (o) t = `${a}${o}`;
            else {
              let e =
                window.Blockly.JavaScript.javascriptGenerator.provideFunction_(
                  "textToTitleCase",
                  [
                    `function ${window.Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_}(str) {
                return str.toLowerCase().split(' ').map(function(word) {
                    return word.replace(word[0], word[0].toUpperCase());
                }).join(' ');
            }`,
                  ]
                );
              t = `${e}(${a})`;
            }
            return [
              t,
              window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
            ];
          }),
        (window.Blockly.Blocks.text_trim = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)(
              "trim spaces from {{ side }} of {{ input_text }}",
              { side: "%1", input_text: "%2" }
            ),
            args0: [
              {
                type: "field_dropdown",
                name: "MODE",
                options: [
                  [(0, i.NC)("both sides"), "BOTH"],
                  [(0, i.NC)("left side"), "LEFT"],
                  [(0, i.NC)("right side"), "RIGHT"],
                ],
              },
              { type: "input_value", name: "TEXT" },
            ],
            output: "String",
            outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
            colour: window.Blockly.Colours.Base.colour,
            colourSecondary: window.Blockly.Colours.Base.colourSecondary,
            colourTertiary: window.Blockly.Colours.Base.colourTertiary,
            tooltip: (0, i.NC)("Trims spaces"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Trim spaces"),
            description: (0, i.NC)(
              "Trims the spaces within a given string or text."
            ),
          }),
          getRequiredValueInputs: () => ({ TEXT: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_trim = (
          e
        ) => {
          let t = {
              LEFT: ".replace(/^[\\s\\xa0]+/, '')",
              RIGHT: ".replace(/[\\s\\xa0]+$/, '')",
              BOTH: ".trim()",
            }[e.getFieldValue("MODE")],
            o =
              window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                e,
                "TEXT",
                window.Blockly.JavaScript.javascriptGenerator.ORDER_MEMBER
              ) || "''";
          return [
            `${o}${t}`,
            window.Blockly.JavaScript.javascriptGenerator.ORDER_FUNCTION_CALL,
          ];
        }),
        (window.Blockly.Blocks.text_print = {
          init() {
            this.jsonInit(this.definition());
          },
          definition: () => ({
            message0: (0, i.NC)("print {{ input_text }}", { input_text: "%1" }),
            args0: [{ type: "input_value", name: "TEXT" }],
            colour: window.Blockly.Colours.Special3.colour,
            colourSecondary: window.Blockly.Colours.Special3.colourSecondary,
            colourTertiary: window.Blockly.Colours.Special3.colourTertiary,
            previousStatement: null,
            nextStatement: null,
            tooltip: (0, i.NC)("Displays a dialog window with a message"),
            category: window.Blockly.Categories.Text,
          }),
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          meta: () => ({
            display_name: (0, i.NC)("Print"),
            description: (0, i.NC)(
              'This block displays a dialog box with a customised message. When the dialog box is displayed, your strategy is paused and will only resume after you click "OK".'
            ),
          }),
          getRequiredValueInputs: () => ({ TEXT: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_print = (
          e
        ) => {
          let t =
            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
              e,
              "TEXT",
              window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
            ) || "''";
          return `window.alert(${t});
`;
        }),
        (window.Blockly.Blocks.text_prompt_ext = {
          init() {
            this.jsonInit(this.definition()),
              this.getField("TYPE").setValidator((e) => {
                "TEXT" === e
                  ? this.setOutput(!0, "String")
                  : "NUMBER" === e && this.setOutput(!0, "Number"),
                  this.initSvg(),
                  this.renderEfficiently();
              });
          },
          customContextMenu(e) {
            (0, a.Z3)(e);
          },
          definition() {
            return {
              message0: (0, i.NC)(
                "prompt for {{ string_or_number }} with message {{ input_text }}",
                { string_or_number: "%1", input_text: "%2" }
              ),
              args0: [
                {
                  type: "field_dropdown",
                  name: "TYPE",
                  options: [
                    [(0, i.NC)("string"), "TEXT"],
                    [(0, i.NC)("number"), "NUMBER"],
                  ],
                },
                { type: "input_value", name: "TEXT" },
              ],
              output:
                "function" == typeof this.getFieldValue &&
                "TEXT" === this.getFieldValue("TYPE")
                  ? "String"
                  : "Number",
              outputShape: window.Blockly.OUTPUT_SHAPE_ROUND,
              colour: window.Blockly.Colours.Special3.colour,
              colourSecondary: window.Blockly.Colours.Special3.colourSecondary,
              colourTertiary: window.Blockly.Colours.Special3.colourTertiary,
              tooltip: (0, i.NC)("Request an input"),
              category: window.Blockly.Categories.Text,
            };
          },
          meta: () => ({
            display_name: (0, i.NC)("Request an input"),
            description: (0, i.NC)(
              'This block displays a dialog box that uses a customised message to prompt for an input. The input can be either a string of text or a number and can be assigned to a variable. When the dialog box is displayed, your strategy is paused and will only resume after you enter a response and click "OK".'
            ),
          }),
          getRequiredValueInputs: () => ({ TEXT: a.cM }),
        }),
        (window.Blockly.JavaScript.javascriptGenerator.forBlock.text_prompt_ext =
          (e) => {
            let t, o;
            return (
              (t = e.getField("TEXT")
                ? window.Blockly.JavaScript.javascriptGenerator.quote_(
                    e.getFieldValue("TEXT")
                  )
                : window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                    e,
                    "TEXT",
                    window.Blockly.JavaScript.javascriptGenerator.ORDER_NONE
                  ) || "''"),
              [
                "NUMBER" === e.getFieldValue("TYPE")
                  ? `parseFloat(window.prompt(${t}))`
                  : `window.prompt(${t})`,
                window.Blockly.JavaScript.javascriptGenerator
                  .ORDER_FUNCTION_CALL,
              ]
            );
          });
    },
  },
]);
